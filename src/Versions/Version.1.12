******************************************************************************
******************************** Version 1.12 ********************************
******************************************************************************

|----------------------------------------------------------------------------|
| CHANGE TYPE:   New ML functions: get_const_type, arity, is_type            |
|----------------------------------------------------------------------------|
| CHANGED BY:    MJCG                                                        |
|----------------------------------------------------------------------------|
| FILES CHANGED: lisp/hol-pars.l                                             |
|----------------------------------------------------------------------------|
| DATE:          1 February 1990                                             |
|----------------------------------------------------------------------------|

The following new functions have been added:

   get_const_type : string -> type
   arity          : string -> int
   is_type        : string -> bool

These, respectively, get the type of a constant from its name, get the
arity of a type operator from its name and tests whether a string is
the name of a type or type operator. 

|----------------------------------------------------------------------------|
| CHANGE TYPE:   Old feature (sections) reinstated                           |
|----------------------------------------------------------------------------|
| CHANGED BY:    MJCG                                                        |
|----------------------------------------------------------------------------|
| FILES CHANGED: lisp/f-parsml.l                                             |
|----------------------------------------------------------------------------|
| DATE:          1 February 1990                                             |
|----------------------------------------------------------------------------|

Sections have been reinstated, but with opening and closing keywords
`begin_section` and `end_section` instead of `begin` and `end`.

Sections are known to have bugs when when values with local types are
exported and they are not intended for general use. They have been
reinstated so that certain ML system functions that are not intended
for general use can be hidden.


|----------------------------------------------------------------------------|
| CHANGE TYPE:   New ML function (set_string_escape)                         |
|----------------------------------------------------------------------------|
| CHANGED BY:    MJCG                                                        |
|----------------------------------------------------------------------------|
| FILES CHANGED: lisp/hol-pars.l                                             |
|----------------------------------------------------------------------------|
| DATE:          1 February 1990                                             |
|----------------------------------------------------------------------------|


The function:

   set_string_escape : int -> int

changes the escape character in strings to be the character with the
supplied ascii code (initially this is 92, viz `\`). The old escape
character is returned.


|----------------------------------------------------------------------------|
| CHANGE TYPE:   New ML function: new_syntax_block                           |
|----------------------------------------------------------------------------|
| CHANGED BY:    MJCG                                                        |
|----------------------------------------------------------------------------|
| FILES CHANGED: lisp/hol-pars.l                                             |
|                lisp/f-parser.l                                             |
|----------------------------------------------------------------------------|
| DATE:          2 February 1990                                             |
|----------------------------------------------------------------------------|


A syntax block starts with keyword and ends with a terminator and is
associated with a function of strings. When such a block is
encountered in the input stream, all the characters between the start
keyword and the terminator are made into a string to which the
associated function is applied.

The ML function:

   new_syntax_block : string # string # string -> void

declares a new syntax block. The first argument is the start keyword
of the block, the second argument is the terminator and the third
argument is the name of a function having a type which is an instance
of string->*. The effect of

   new_syntax_block(`XXX`, `YYY`, `Fun`);;

is that if

   XXX 
    
      ...

   YYY

occurs in the input, then it is as though

   Fun `

      ...

   `

were input.

For example:

   #let foo s = print_string `Hello: `; print_string s; print_newline();;
   foo = - : (string -> void)

   #new_syntax_block(`FOO`,`OOF`, `foo`);;
   () : void
 
   #FOO 123OO44OOF;;
   Hello: 123OO44
   () : void

   #FOO
   #splat
   #OOF;;
   Hello: splat

   () : void

   #



|----------------------------------------------------------------------------|
| CHANGE TYPE:   New ML flag (file_load_msg)                                 |
|----------------------------------------------------------------------------|
| CHANGED BY:    MJCG                                                        |
|----------------------------------------------------------------------------|
| FILES CHANGED: lisp/f-iox-stand.l                                          |
|                lisp/f-tml.l                                                |
|----------------------------------------------------------------------------|
| DATE:          10 February 1990                                            |
|----------------------------------------------------------------------------|

When the flag `file_load_flag` is true (the default) a message is
printed after a file is loaded. When it is false no message is printed.

+----------------------------------------------------------------------------+
| CHANGE TYPE:   Deletion (ml function abbrev_ty_def)		             |
|----------------------------------------------------------------------------|
| CHANGED BY:    TFM                                                         |
|----------------------------------------------------------------------------|
| FILES CHANGED: ml/hol-syn.ml						     |
|----------------------------------------------------------------------------|
| DATE:          7  April 1990                                               |
+----------------------------------------------------------------------------+

The ml function abbrev_ty_def is no longer required, and its definition has 
therefore been deleted from the ml file ml/hol-syn.ml.  The REFERENCE manual
entry for this function has also been deleted.

+----------------------------------------------------------------------------+
| CHANGE TYPE:   Hiding of local functions.		     		     |
|----------------------------------------------------------------------------|
| CHANGED BY:    TFM                                                         |
|----------------------------------------------------------------------------|
| FILES CHANGED: ml/hol-syn.ml						     |
|----------------------------------------------------------------------------|
| DATE:          7  April 1990                                               |
+----------------------------------------------------------------------------+

The following ML functions, which are required only for internal use, have 
been made local in the ML file hol-syn.ml.  They are therefore no longer 
available at the top-level of HOL.

   mk_quant, mk_bool_comb, space, ascii_ize, truth, dest_quant,
   dest_bool_comb

The REFERENCE manual entries for these functions have been deleted.

+----------------------------------------------------------------------------+
| CHANGE TYPE:   Hiding of local functions.		     		     |
|----------------------------------------------------------------------------|
| CHANGED BY:    TFM                                                         |
|----------------------------------------------------------------------------|
| FILES CHANGED: ml/hol-thyfns.ml					     |
|----------------------------------------------------------------------------|
| DATE:          9  April 1990                                               |
+----------------------------------------------------------------------------+

The following ML functions, which are required only for internal use, have 
been made local in the ML file hol-thyfns.ml.  They are therefore no longer 
available at the top-level of HOL.

   pp_constants, pp_axioms

The REFERENCE manual entries for these functions have been deleted.

+----------------------------------------------------------------------------+
| CHANGE TYPE:   Modified failure strings.		     		     |
|----------------------------------------------------------------------------|
| CHANGED BY:    TFM                                                         |
|----------------------------------------------------------------------------|
| FILES CHANGED: ml/hol-syn.ml						     |
|----------------------------------------------------------------------------|
| DATE:          7  April 1990                                               |
+----------------------------------------------------------------------------+

The following ML functions now fail with the failure strings shown below, 
rather than with `mk_abs`, `mk_comb`, etc.

   mk_exists	 fails with    `mk_exists`
   mk_forall 	 fails with    `mk_forall`
   mk_conj 	 fails with    `mk_conj`
   mk_disj 	 fails with    `mk_disj`
   mk_imp 	 fails with    `mk_imp`
   mk_iff 	 fails with    `mk_iff`
   mk_eq 	 fails with    `mk_eq`
   mk_neg 	 fails with    `mk_neg`

   dest_select 	 fails with    `dest_select`

Some of these functions have also been very slightly optimized.

+----------------------------------------------------------------------------+
| CHANGE TYPE:   new ML function: is_axiom			 	     |
|----------------------------------------------------------------------------|
| CHANGED BY:    TFM                                                         |
|----------------------------------------------------------------------------|
| FILES CHANGED: lisp/f-thyfns.l					     |
|----------------------------------------------------------------------------|
| DATE:          7  April 1990                                               |
+----------------------------------------------------------------------------+

A new ML function is defined:

   is_axiom : (string # string) -> bool

This function takes a theory name and a string, and tests whether 
an axiom, definition, type definition, or constant specification
is stored in the given theory under the supplied name.  That is:

   is_axiom (<th>,<name>)

is true iff there is an axiom (or definition) stored in the theory <th>
under the name <name>. Fails if <th> is not an ancestor of the current theory.
Note that definitions, constant specifications and type definitions are
regarded as axioms by this function (which, indeed, they logically are).

An entry in the REFERENCE manual has been added for this new function.

+----------------------------------------------------------------------------+
| CHANGE TYPE:   rewrite of new_type_definition.			     |
|----------------------------------------------------------------------------|
| CHANGED BY:    TFM                                                         |
|----------------------------------------------------------------------------|
| FILES CHANGED: ml/hol-syn.ml						     |
|----------------------------------------------------------------------------|
| DATE:          7  April 1990                                               |
+----------------------------------------------------------------------------+

The ML function new_type_definition has been rewritten.  The rewrite was done
mainly to incorporate some changes made for HOL88 in a better fashon.  But 
there are also two changes which may affect users.  Only one of these is
an incompatible modification.  The changes which affect users are:

1) new_type_definition now issues better error messages when it fails.  

2) The resulting type definition is now stored (as a definition) under
   the name `<op>_TY_DEF`, where <op> is the name of the type or type 
   operator which has been defined.  This is a change from the old
   automatically-generated name `<op>_AXIOM`. Furthermore, a call:

	new_type_definition(`op`, P, |- ?x. P x)

   will now FAIL (with an appropriate message) if there is already an
   axiom, definition, type definition, or constant specification stored
   under the name `op_TY_DEF` in the current theory.  Thus the code is now
   consistent with the manual entry for new_type_definition.  (The old
   version, in a clumsy attempt to be atomic, used to add primes to the 
   name `op_AXIOM` until it could store the definition under that name.)

Neither change is likely to affect the average HOL user. The manual
(DESCRIPTION 11.6.2.3 and REFERENCE) has been updated.

+----------------------------------------------------------------------------+
| CHANGE TYPE:   Deletion (ml function EXPAND_TY_DEF)		             |
|----------------------------------------------------------------------------|
| CHANGED BY:    TFM                                                         |
|----------------------------------------------------------------------------|
| FILES CHANGED: ml/hol-syn.ml, ml/hol-rule.ml				     |
|		 ml/tydefs.ml + built-in theories and libraries.	     |
|----------------------------------------------------------------------------|
| DATE:          10 April 1990                                               |
+----------------------------------------------------------------------------+

In previous versions of HOL, the ml function EXPAND_TY_DEF was used
exclusively as an interface between new_type_definition and
define_new_type_isomorphisms. This interface is no longer required, and the
definition of EXPAND_TY_DEF has therefore been deleted from the system.  The
REFERENCE manual entry for this function has also been deleted, and the
discussion in DESCRIPTION updated.

Users needing to expand an abbreviated type definition may rewrite with the
defining equation bound to the ML identifier TYPE_DEFINITION. 

+----------------------------------------------------------------------------+
| CHANGE TYPE:   New conversion: X_FUN_EQ_CONV				     |
|----------------------------------------------------------------------------|
| CHANGED BY:    TFM                                                         |
|----------------------------------------------------------------------------|
| FILES CHANGED: ml/conv.ml						     |
|----------------------------------------------------------------------------|
| DATE:          10 April 1990                                               |
+----------------------------------------------------------------------------+

The conversion FUN_EQ_CONV allows one to move from functional equality
to point-wise equality.  I.e. FUN_EQ_CONV "f = g" yields:

   |-  (f = g) = (!x. f x = g x)

The problem, however, is that FUN_EQ_CONV picks the name of the variable,
which, in this particular example, happens to be "x".  The new conversion
X_FUN_EQ_CONV allows the user to supply the variable to be quantified over.
Evaluating:

   X_FUN_EQ_CONV "y" "f = g"

yields the theorem:

   |- (f = g) = (!y. f y = g y)

This fails if y is free in f or g, or y is not of the right type, or y is not
a variable, or (finally) if f and g are not functions.  X_FUN_EQ_CONV issues a
sensible but concise error message (i.e. error string) for every possible
failure.  A preliminary REFERENCE manual entry exists.

+----------------------------------------------------------------------------+
| CHANGE TYPE:   Revision of built-in theory sum.th			     |
|----------------------------------------------------------------------------|
| CHANGED BY:    TFM                                                         |
|----------------------------------------------------------------------------|
| FILES CHANGED: theories/mk_sum.ml					     |
|----------------------------------------------------------------------------|
| DATE:          11 April 1990                                               |
+----------------------------------------------------------------------------+

The built-in theory "sum.th" has been rewritten to take advantage of the
constant specification mechanism.  The constants ISL, ISR, OUTL, and OUTR
are now defined by the constant specifications:

   ISL   |- (!x. ISL(INL x)) /\ (!y. ~ISL(INR y))
   ISR   |- (!x. ISR(INR x)) /\ (!y. ~ISR(INL y))
   OUTL  |- !x. OUTL(INL x) = x
   OUTR  |- !x. OUTR(INR x) = x

These are therefore now definitions in the theory sum, rather than theorems.
The old definitions of ISL, ISR, OUTL, and OUTR have been deleted from the
theory and the REFERENCE manual.

The theory sum also no longer defines the constant 

   Sum: (*->***) -> (**->***) -> ((*,**)sum -> ***)

so the identifier "Sum" is now avaliable for user definitions of new
constants.  All REFERENCE entries concerned with the Sum have been deleted.

The theorem sum_Axiom has been renamed:

    sum_axiom = |- !f g. ?! h. (h o INL = f) /\ (h o INR = g)

and an additional theorem

    sum_Axiom = |- !f g. ?! h. (!x. h(INL x) = f x) /\ (!x. h(INR x) = g x)

has been added to the theory.  This second theorem is in the right form for
use with the tools associated with automatic recursive type definitions.
For example, an "induction" theorem for disjoint sums can be proved by:

    let sum_Induct = prove_induction_thm sum_Axiom;;

Likewise, new_recursive_definition will work with sum_Axiom for defining
functions on disjoint sums by cases.

Finally, the theory sum no longer uses the combinators K and I from
the theory combin.

+----------------------------------------------------------------------------+
| CHANGE TYPE:   Revision of built-in theory tydefs.th			     |
|----------------------------------------------------------------------------|
| CHANGED BY:    TFM                                                         |
|----------------------------------------------------------------------------|
| FILES CHANGED: theories/mk_tydefs.ml ml/tydefs.ml			     |
|----------------------------------------------------------------------------|
| DATE:          11 April 1990                                               |
+----------------------------------------------------------------------------+

Two logically redundant assumptions about ABS and REP have been deleted from
the theorem TY_DEF_THM in tydefs.th.

+----------------------------------------------------------------------------+
| CHANGE TYPE:   New subdirectory (contrib)				     |
|----------------------------------------------------------------------------|
| CHANGED BY:    TFM/JVT                                                     |
|----------------------------------------------------------------------------|
| FILES CHANGED: hol/contrib						     |
|----------------------------------------------------------------------------|
| DATE:          11 April 1990                                               |
+----------------------------------------------------------------------------+

As was discussed at the second HOL user's meeting, a contrib directory has
been instituted for the HOL distribution.  This directory contains
contributions from the HOL user community which are distributed with the HOL
source.  The contributions are not edited, and the University of Cambridge
Computer Laboratory assumes no responsibility to support any HOL code or tools
distributed in this directory.

The aim of contrib is to provide a vehicle to make it easy for the HOL
community to share theories, proofs, examples, tools, documents, and other
material which may be of interest to users of the HOL system, but which is
not included in the library.

Each contribution is given a separate subdirectory within contrib. A standard
READ-ME file is included in each subdirectory, giving at least the following
information: 

   * name of the subdirectory
   * a one-line description of the contents
   * names and addresses of the authors, 
   * date of inclusion in contrib

Contributors may also include other information in the READ-ME file.

More contributed material from users is most welcome.

+----------------------------------------------------------------------------+
| CHANGE TYPE:   Hiding of intermediate lemma.				     |
|----------------------------------------------------------------------------|
| CHANGED BY:    TFM                                                         |
|----------------------------------------------------------------------------|
| FILES CHANGED: theories/mk_arith_thms.ml				     |
|----------------------------------------------------------------------------|
| DATE:          11 April 1990                                               |
+----------------------------------------------------------------------------+

The theorem TOTALLY_AD_HOC_LEMMA is now no longer saved in the arithmetic
theory, and is not available at top-level.  Its REFERENCE manual entry has
been deleted.

+----------------------------------------------------------------------------+
| CHANGE TYPE:   Rewrite of define_new_type_isomorphisms		     |
|----------------------------------------------------------------------------|
| CHANGED BY:    TFM                                                         |
|----------------------------------------------------------------------------|
| FILES CHANGED: ml/abs-rep.ml + theories and libraries			     |
|----------------------------------------------------------------------------|
| DATE:          11 April 1990                                               |
+----------------------------------------------------------------------------+

The ML function define_new_type_isomorphisms has been rewritten and improved.
Here is how it USED to work.  Suppose that a type definition was made by 
by calling:

  let tyax = new_type_definition(`ty`, "P", |- ?x. P x);;

Then define_new_type_isomorphisms could be used to define an abstraction 
function ABS_ty and a representation function REP_ty and derive a collection
of six theorems about them.  One had to first expand tyax using EXPAND_TY_DEF.

  let [R_11;R_ONTO;A_11;A_ONTO;A_R;R_A] = 
      define_new_type_isomorphisms (EXPAND_TY_DEF tyax);;

This would yield the following six theorems:

  R_11    |- !a a'. (REP_ty a = REP_ty a') = (a = a')

  R_ONTO  |- !r. P r = (?a. r = REP_ty a)

  A_11    |- !r r'. P r ==> P r' ==> ((ABS_ty r = ABS_ty r') = (r = r'))

  A_ONTO  |- !a. ?r. (a = ABS_ty r) /\ P r

  A_R     |- !a. ABS_ty(REP_ty a) = a

  R_A     |- !r. P r = (REP_ty(ABS_ty r) = r)

The problems with this approach were:

 1) You had to call EXPAND_TY_DEF.

 2) You had no choice of names for the abstraction and representation
    functions.  They were just generated, and called ABS_ty and REP_ty,
    where ty was the name of the type involved.

 3) None of the theorems returned were saved in a theory file.

 4) The list of theorems returned was redundant (this is bad for
    automating higher-level type definition tools, where redundancy
    equals slowness).

 5) The function define_new_type_isomorphisms made a mess of your theory
    file with the epsilon definitions of ABS_ty and REP_ty.

The current version of define_new_type_isomorphisms is intended to 
fix these problems.  The type of this function is now as follows:

  define_new_type_isomorphisms : string -> string -> string -> thm -> thm

The first argument is the name under which the resulting theorem will be
stored (as a definition) in the current theory file.  The second and third
arguments are the names of the abstraction and representation functions which
will be defined.  The fourth argument is a theorem of the form returned by
new_type_definition (in unexpanded form). The result is the defining property
of these abstraction and representation functions, given by the conjunction of
what above were called A_R and R_A.

For example if you define:

  let tyax = new_type_definition(`ty`,"P","?x. P x");;

then executing:

  let thm = define_new_type_isomorphisms `ty_ISO_DEF` `ABS` `REP` tyax;;

Will define two functions called `ABS` and `REP` such that:

  thm  |- (!a. ABS(REP a) = a) /\ (!r. P r = (REP(ABS r) = r))

and store this defining property (which is also the theorem returned) as a
definition under the name ty_ISO_DEF in the current theory.

The manual has been updated with a description of the new behaviour of
define_new_type_isomorphisms.  For an explanation of how to get the 
theorems called R_11, R_ONTO, A_11 and A_ONTO above, see below.

+----------------------------------------------------------------------------+
| CHANGE TYPE:   New ML functions.					     |
|----------------------------------------------------------------------------|
| CHANGED BY:    TFM                                                         |
|----------------------------------------------------------------------------|
| FILES CHANGED: ml/abs-rep.ml + theories and libraries.		     |
|----------------------------------------------------------------------------|
| DATE:          11 April 1990                                               |
+----------------------------------------------------------------------------+

To regain the full functionality provided by the old version of
define_new_type_isomorphisms, the following four new ML functions are now
provided as built-in tools:

   prove_rep_fn_one_one : thm -> thm
   prove_rep_fn_onto    : thm -> thm
   prove_abs_fn_one_one : thm -> thm
   prove_abs_fn_onto    : thm -> thm

Each of these functions takes a theorem of the form returned by
define_new_type_isomorphisms, and proves a simple consequence about either the
abstraction or representation function involved.  Suppose we have:

  let thm = 
      let tyax = new_type_definition(`ty`,"P","?x. P x") in
      define_new_type_isomorphisms `ty_ISO_DEF` `ABS` `REP` tyax;;

so that 

  thm = |- (!a. ABS(REP a) = a) /\ (!r. P r = (REP(ABS r) = r)).

Then here is what each function does.

  * prove_rep_fn_one_one thm proves that REP is one-to-one:

      |- !a a'. (REP a = REP a') = (a = a')

  * prove_rep_fn_onto thm proves that REP is onto:

      |- !r. P r = (?a. r = REP a)

  * prove_abs_fn_one_one thm proves that ABS is one-to-one:

      |- !r r'. P r ==> P r' ==> ((ABS r = ABS r') = (r = r'))

  * prove_abs_fn_onto thm proves that ABS is onto:

      |- !a. ?r. (a = ABS r) /\ P r

None of these four calls saves anything on the current theory file. (In fact,
it should usually be unnecessary to save them, since they can be generated
quickly whenever required from the theorem returned by the ML function
define_new_type_isomorphisms, which is itself saved.  Of course, within any
given session, one would bind the results to ML identifiers.)

+----------------------------------------------------------------------------+
| CHANGE TYPE:   Hiding of intermediate lemmas.				     |
|----------------------------------------------------------------------------|
| CHANGED BY:    TFM                                                         |
|----------------------------------------------------------------------------|
| FILES CHANGED: ml/hol-drule.ml					     |
|----------------------------------------------------------------------------|
| DATE:          18 April 1990                                               |
+----------------------------------------------------------------------------+

The following built-in theorems:

    AND_CLAUSE1 = |- !t. T /\ t = t

    AND_CLAUSE2 = |- !t. t /\ T = t

    AND_CLAUSE3 = |- !t. F /\ t = F

    AND_CLAUSE4 = |- !t. t /\ F = F

    AND_CLAUSE5 = |- !t. t /\ t = t

have been made into strictly local lemmas in ml/hol-drule.ml. They are no
longer available at top-level.  The REFERENCE manual entries for these 
theorems have been deleted.  Users should instead use the truth-table:

    AND_CLAUSES = 
    |- !t.
        (T /\ t = t) /\
        (t /\ T = t) /\
        (F /\ t = F) /\
        (t /\ F = F) /\
        (t /\ t = t)


+----------------------------------------------------------------------------+
| CHANGE TYPE:   Deletions (paired versions of ml curried functions etc)     |
|----------------------------------------------------------------------------|
| CHANGED BY:    TFM                                                         |
|----------------------------------------------------------------------------|
| FILES CHANGED: lisp/f-lis.l ml/ml-curry.ml lisp/f-simpl.l ml/hol-syn.ml    |
|		 lisp/f-subst.l lisp/f-inst.l lisp/f-obj.l		     |
|----------------------------------------------------------------------------|
| DATE:          19 April 1990                                               |
+----------------------------------------------------------------------------+

The ML functions:

    paired_mem		paired_tryfind	   paired_aconv_term
    paired_map		paired_filter      paired_subst_term
    paired_forall	paired_mapfilter   paired_subst_occs_term
    paired_exists	paired_rev_itlist  paired_term_freein_term
    paired_find		paired_term_match  paired_type_in_term

    paired_type_in_type paired_set_left    paired_axiom
    paired_inst_type    paired_set_right
    paired_inst_term    paired_cons
    paired_variant      paired_eq


were defined (for implementation purposes) as paired versions of the curried
functions mem, map, etc.  These paired functions are not required at
top-level, and have therefore been deleted (or, more strictly speaking,
renamed to be mem, map, etc and then later masked by the curried functions).

The preliminary REFERENCE manual entries for these functions have been
deleted.

+----------------------------------------------------------------------------+
| CHANGE TYPE:   Deletions ("form" syntax functions)   			     |
|----------------------------------------------------------------------------|
| CHANGED BY:    TFM                                                         |
|----------------------------------------------------------------------------|
| FILES CHANGED: lisp/f-simpl.l lisp/f-writol.l lisp/f-inst.l		     |
|----------------------------------------------------------------------------|
| DATE:          19 April 1990                                               |
+----------------------------------------------------------------------------+

The functions

    paired_form_match 
    paired_aconv_form
    paired_subst_form 
    paired_subst_occs_form
    paired_term_freein_form
    paired_term_freein_form
    paired_type_in_form
    paired_inst_form
    rename_form
    print_form
    rename_term
    mk_inequiv
    dest_inequiv
    is_inequiv
    is_equiv
    dest_equiv
    mk_equiv
    gen_all
    new_predicate

are used nowhere in HOL, and their definitions has therefore been deleted 
(commented-out, actually).  The preliminary REFERENCE manual entries for 
these functions have also been deleted.


+----------------------------------------------------------------------------+
| CHANGE TYPE:   Hiding of intermediate lemmas.				     |
|----------------------------------------------------------------------------|
| CHANGED BY:    TFM                                                         |
|----------------------------------------------------------------------------|
| FILES CHANGED: ml/hol-drule.ml					     |
|----------------------------------------------------------------------------|
| DATE:          20 April 1990                                               |
+----------------------------------------------------------------------------+

The following built-in theorems:

   OR_CLAUSE1 = |- !t. T \/ t = T

   OR_CLAUSE2 = |- !t. t \/ T = T

   OR_CLAUSE3 = |- !t. F \/ t = t

   OR_CLAUSE4 = |- !t. t \/ F = t

   OR_CLAUSE5 = |- !t. t \/ t = t

have been made into strictly local lemmas in ml/hol-drule.ml. They are no
longer available at top-level.  The REFERENCE manual entries for these 
theorems have been deleted.  Users should instead use the truth-table:

   OR_CLAUSES = 
   |- !t.
       (T \/ t = T) /\
       (t \/ T = T) /\
       (F \/ t = t) /\
       (t \/ F = t) /\
       (t \/ t = t)

+----------------------------------------------------------------------------+
| CHANGE TYPE:   Hiding of intermediate lemmas.				     |
|----------------------------------------------------------------------------|
| CHANGED BY:    TFM                                                         |
|----------------------------------------------------------------------------|
| FILES CHANGED: ml/hol-drule.ml					     |
|----------------------------------------------------------------------------|
| DATE:          20 April 1990                                               |
+----------------------------------------------------------------------------+

The following built-in theorems:

   IMP_CLAUSE1 = |- !t. T ==> t = t

   IMP_CLAUSE2 = |- !t. F ==> t = T

   IMP_CLAUSE3 = |- !t. t ==> T = T

   IMP_CLAUSE4 = |- (T ==> F = F) /\ (F ==> F = T)

   IMP_CLAUSE5 = |- !t. t ==> F = ~t

have been made into strictly local lemmas in ml/hol-drule.ml. They are no
longer available at top-level.  The REFERENCE manual entries for these 
theorems have been deleted.  Users should instead use the truth-table:

   IMP_CLAUSES = 
   |- !t.
       (T ==> t = t) /\
       (t ==> T = T) /\
       (F ==> t = T) /\
       (t ==> t = T) /\
       (t ==> F = ~t)

+----------------------------------------------------------------------------+
| CHANGE TYPE:   Hiding of intermediate lemmas.				     |
|----------------------------------------------------------------------------|
| CHANGED BY:    TFM                                                         |
|----------------------------------------------------------------------------|
| FILES CHANGED: ml/drul.ml					     	     |
|----------------------------------------------------------------------------|
| DATE:          20 April 1990                                               |
+----------------------------------------------------------------------------+

The following built-in theorems:

   EQ_CLAUSE1 = |- !t. (T = t) = t

   EQ_CLAUSE2 = |- !t. (t = T) = t

   EQ_CLAUSE3 = |- !t. (F = t) = ~t

   EQ_CLAUSE4 = |- !t. (t = F) = ~t

have been made into strictly local lemmas in ml/dule.ml. They are no
longer available at top-level.  The REFERENCE manual entries for these 
theorems have been deleted.  Users should instead use the truth-table:

   EQ_CLAUSES = 
   |- !t.
       ((T = t) = t) /\ ((t = T) = t) /\ ((F = t) = ~t) /\ ((t = F) = ~t)


+----------------------------------------------------------------------------+
| CHANGE TYPE:   Deletion of unused functions.		     		     |
|----------------------------------------------------------------------------|
| CHANGED BY:    TFM                                                         |
|----------------------------------------------------------------------------|
| FILES CHANGED: ml/hol-syn.ml ml/lis.ml ml/genfns.ml			     |
|----------------------------------------------------------------------------|
| DATE:          21 April 1990                                               |
+----------------------------------------------------------------------------+

The following ML functions were defined but nowhere used (or could be easily
replaced by something else). They have therefore been deleted (commented-out)
and are no longer available at the top-level of HOL.

   new_pp_predicate
   diagonal
   nil
   eqfst
   eqsnd
   flip

The REFERENCE manual entries for these functions have been deleted.


+----------------------------------------------------------------------------+
| CHANGE TYPE:   Reorganization and rationalization.			     |
|----------------------------------------------------------------------------|
| CHANGED BY:    TFM                                                         |
|----------------------------------------------------------------------------|
| FILES CHANGED: ml/resolve.ml						     |
|----------------------------------------------------------------------------|
| DATE:          24 April 1990                                               |
+----------------------------------------------------------------------------+

The source code for the resolution tactics has been restructured in order to
remove the traces of obsolete code for resolution.  The following functions
have been deleted or made local in the file resolve.ml.  

  OLD_IMP_RES_TAC    HOL_IMP_RES_THEN   HOL_STRIP_THM_THEN
  OLD_RES_TAC        HOL_RES_THEN       HOL_STRIP_ASSUME_TAC
  OLD_IMP_RES_THEN   RES_CANON_FUN 	HOL_MATCH_MP
  OLD_RES_THEN	     MULTI_MP		HOL_RESOLVE_THEN
					HOL_PART_MATCH

These functions are no longer available to users, and the preliminary
REFERENCE entries for them have been deleted.


+----------------------------------------------------------------------------+
| CHANGE TYPE:   Improvement in `resolution' tactics.			     |
|----------------------------------------------------------------------------|
| CHANGED BY:    TFM                                                         |
|----------------------------------------------------------------------------|
| FILES CHANGED: ml/resolve.ml						     |
|----------------------------------------------------------------------------|
| DATE:          24 April 1990                                               |
+----------------------------------------------------------------------------+

The resolution tactics:

  RES_THEN IMP_RES_THEN RES_TAC IMP_RES_TAC

are modified in version 1.12 to include:

    !x. t1 ==> t2  --->  t1 ==> !x.t2   (x not free in t1)

in the transformations that are done (by RES_CANON) when a theorem is 
being prepared for resolution.  This prevents specialization of variables 
from happening too early during the process of adding assumptions.

For example, in the old version the theorem:

   LESS_TRANS  |- !m n p. m < n /\ n < p ==> m < p

would be transformed to:

   |- !m n p. m < n ==> (n < p ==> m < p)

But when resolved with the assumptions 

   [ a < b ]
   [ b < c ]

thie would not yield the expected result a < c, since the 
resulting additional assumptions

   [ b < p ==> a < p ]
   [ c < p ==> b < p ]

would effectively "freeze" the variable "p".

The new transformation gives:

   |- !n m. m < n ==> (!p. n < p ==> m < p)

which results in the added assumptions:

   [ !p. b < p ==> a < p ]
   [ !p. c < p ==> b < p ]

from which further results (in particular, a < c) can be obtained.

This is, unfortunately, a possibly NON-COMPATIBLE change.  Goal-directed
proofs may not run in the new version, particularly if they are sensitive 
to the exact ordering or number of assumptions in the goals.  But it was 
thought that the benefits of handling universal quantitifiers properly
would outweigh the irritation of some users having to re-run their proofs.
Note that it is always a good idea to make tactic proofs robust under a change
of ordering on the assumption list.

+----------------------------------------------------------------------------+
| CHANGE TYPE:   Deletion: forwards chaining.				     |
|----------------------------------------------------------------------------|
| CHANGED BY:    TFM                                                         |
|----------------------------------------------------------------------------|
| FILES CHANGED: ml/resolve.ml ml/drul.ml				     |
|----------------------------------------------------------------------------|
| DATE:          24 April 1990                                               |
+----------------------------------------------------------------------------+

The built-in functions having to do with forwards chaining:

    MP_CHAIN
    REDEPTH_CHAIN
    SUB_CHAIN
    ONCE_DEPTH_CHAIN
    DSPEC
    DSPECL

have been deleted until a need is found for them and they have been 
properly reimplemented for HOL (they were originally inherited from
LCF).  Interested users can find the source on ml/drul.ml.
The preliminary REFERENCE manual entries have also been deleted.

+----------------------------------------------------------------------------+
| CHANGE TYPE:   Hiding of intermediate lemmas.				     |
|----------------------------------------------------------------------------|
| CHANGED BY:    TFM                                                         |
|----------------------------------------------------------------------------|
| FILES CHANGED: ml/drul.ml					     	     |
|----------------------------------------------------------------------------|
| DATE:          24 April 1990                                               |
+----------------------------------------------------------------------------+

The following built-in theorems:

    COND_CLAUSE1 = |- !t1 t2. (T => t1 | t2) = t1

    COND_CLAUSE2 = |- !t1 t2. (F => t1 | t2) = t2

have been made into strictly local lemmas in ml/drul.ml. They are no
longer available at top-level.  The REFERENCE manual entries for these 
theorems have been deleted.  Users should instead use the theorem:

    COND_CLAUSES = |- !t1 t2. ((T => t1 | t2) = t1) /\ ((F => t1 | t2) = t2)

+----------------------------------------------------------------------------+
| CHANGE TYPE:   Hiding of local functions.		     		     |
|----------------------------------------------------------------------------|
| CHANGED BY:    TFM                                                         |
|----------------------------------------------------------------------------|
| FILES CHANGED: ml/hol-thyfn.ml					     |
|----------------------------------------------------------------------------|
| DATE:          7  April 1990                                               |
+----------------------------------------------------------------------------+

The following ml functions, which are required only internally, have been
made local in the file hol-thyfn.ml:

    print_tok_ty
    print_tok_thm
    apply_type_op
    print_all_tok_thm

They are no longer available at top-level, and their preliminary REFERENCE
manual entries have been deleted.

+----------------------------------------------------------------------------+
| CHANGE TYPE:   Modified conversion: EXISTS_UNIQUE_CONV.    		     |
|----------------------------------------------------------------------------|
| CHANGED BY:    TFM                                                         |
|----------------------------------------------------------------------------|
| FILES CHANGED: ml/conv.ml						     |
|----------------------------------------------------------------------------|
| DATE:          6 May 1990.						     |
+----------------------------------------------------------------------------+

The built-in conversion EXISTS_UNIQUE_CONV, which expands with the definition
of unique existence, has been modified to behave as follows.  Given a term of
the form "?!v.P[v]", the new conversion returns the theorem:

   |- ?!v.P[v] = ?v.P[v] /\ !x y. P[x] /\ P[y] ==> (x=y)

The old version, in this case, would returned the theorem

   |- ?!v.P[v] = ?v.P[v] /\ !x y. (\v.P[v]) x /\ (\v.P[v]) y ==> (x=y)

That is, no beta-conversion would be done in the uniqueness part.

The new version of EXISTS_UNIQUE_CONV fails, with an informative failure
string, if applied to a term which is not of the form ?!x.P[x].


+----------------------------------------------------------------------------+
| CHANGE TYPE:   Deletions (tok_of_int and int_of_tok)		             |
|----------------------------------------------------------------------------|
| CHANGED BY:    TFM                                                         |
|----------------------------------------------------------------------------|
| FILES CHANGED: lisp/f-dml.l						     |
|----------------------------------------------------------------------------|
| DATE:          6 May 1990.						     |
+----------------------------------------------------------------------------+

The ML functions tok_of_int and int_of_tok are superseded by the built-in
functions string_of_int and int_of_string, which do exactly the same things.
The functions  tok_of_int and int_of_tok have therefore been deleted, both
from the system and from the REFERENCE manual.  Users should update their
code by substituting:

	int_of_string	for 	int_of_tok
	string_of_int 	for 	tok_of_int

wherever these functions are used.


+----------------------------------------------------------------------------+
| CHANGE TYPE:   Hiding of local functions.		     		     |
|----------------------------------------------------------------------------|
| CHANGED BY:    TFM                                                         |
|----------------------------------------------------------------------------|
| FILES CHANGED: ml/numconv.ml						     |
|----------------------------------------------------------------------------|
| DATE:          6 May 1990.						     |
+----------------------------------------------------------------------------+

The functions int_to_term and term_to_int, defined by:

   let int_to_term n = mk_const(string_of_int n, ":num") and
       term_to_int n = int_of_string(fst(dest_const n));;

have been made local (deleted actually) in the file numconv.ml, and they are
therefore no longer available at top-level.  Their REFERENCE manual entries
have been deleted.

+----------------------------------------------------------------------------+
| CHANGE TYPE:   Modified failure strings (num_CONV).			     |
|----------------------------------------------------------------------------|
| CHANGED BY:    TFM                                                         |
|----------------------------------------------------------------------------|
| FILES CHANGED: ml/numconv.ml						     |
|----------------------------------------------------------------------------|
| DATE:          6 May 1990.						     |
+----------------------------------------------------------------------------+

The conversion num_CONV now fails with more informative failure strings.

+----------------------------------------------------------------------------+
| CHANGE TYPE:   Modified failure string (CONJ_PAIR).			     |
|----------------------------------------------------------------------------|
| CHANGED BY:    TFM                                                         |
|----------------------------------------------------------------------------|
| FILES CHANGED: ml/drul.ml						     |
|----------------------------------------------------------------------------|
| DATE:          6 May 1990.						     |
+----------------------------------------------------------------------------+

The inference rule CONJ_PAIR now fails with a more informative failure string.


+----------------------------------------------------------------------------+
| CHANGE TYPE:   New inference rule (EQF_INTRO).			     |
|----------------------------------------------------------------------------|
| CHANGED BY:    TFM                                                         |
|----------------------------------------------------------------------------|
| FILES CHANGED: ml/hol-drule.ml					     |
|----------------------------------------------------------------------------|
| DATE:          6 May 1990.						     |
+----------------------------------------------------------------------------+

A new inference rule, EQF_INTRO:

      ~tm
   -----------    
     tm = F

has been installed.  This rule is used for introducing equality with "F".

+----------------------------------------------------------------------------+
| CHANGE TYPE:   Revised tactic (COND_CASES_TAC).			     |
|----------------------------------------------------------------------------|
| CHANGED BY:    TFM                                                         |
|----------------------------------------------------------------------------|
| FILES CHANGED: ml/hol-drule.ml					     |
|----------------------------------------------------------------------------|
| DATE:          11 May 1990.						     |
+----------------------------------------------------------------------------+

The built-in tactic COND_CASES_TAC has been revised to have the behaviour
specified by:

	t[p=>u|v]	
    =================	COND_CASES_TAC	
        {p}  t[u]
       {~p}  t[v]

That is, COND_CASES_TAC finds a conditional "p => u | v" which is free in the
goal (the condition p of which is not a constant) and performs a case split on
this condition.  The terms "p" and "~p" are added to the assumptions of two
resulting subgoals.

The behaviour of the previous version of COND_CASES_TAC	was similar, except
that the terms "p=T" and "p=F" were added to the assumptions of the resulting
subgoals:

	t[p=>u|v]	
    =================	COND_CASES_TAC	(old version, now superseded)
       {p=T}  t[u]
       {p=F}  t[v]

But this was really an artifact of the derivation of this tactic from LCF, and
meant that HOL-style resolution (ie using IMP_RES_TAC etc) could not make use
of these new assumptions.  

This is a NON-COMPATIBLE change, and users may have to revise goal-directed
proofs in which COND_CASES_TAC is used.

+----------------------------------------------------------------------------+
| CHANGE TYPE:   Additions to arithmetic.th.			     	     |
|----------------------------------------------------------------------------|
| CHANGED BY:    TFM                                                         |
|----------------------------------------------------------------------------|
| FILES CHANGED: theories/mk_arith_thms.ml ml/load_thms.ml 		     |
|		 (+ REFERENCE manual)			     		     |
|----------------------------------------------------------------------------|
| DATE:          26 May 1990.						     |
+----------------------------------------------------------------------------+

The following new arithmetic theorems (needed for other enhancements in
version 12, but generally useful) are now built in:

  LESS_EQUAL_ANTISYM    |- !n m. n <= m /\ m <= n ==> (n = m)

  LESS_ADD_SUC          |- !m n. m < (m + (SUC n))

+----------------------------------------------------------------------------+
| CHANGE TYPE:   Addition to theory arithmetic.th.			     |
|----------------------------------------------------------------------------|
| CHANGED BY:    TFM                                                         |
|----------------------------------------------------------------------------|
| FILES CHANGED: theories/mk_arith.ml theories/mk_arith_thms.ml 	     |
|		 ml/load_thms.ml (+ REFERENCE manual)			     |
|----------------------------------------------------------------------------|
| DATE:          26 May 1990.						     |
+----------------------------------------------------------------------------+

The built-in theory arithmetic has been augmented with a minimal theory of
the functions MOD and DIV on the natural numbers.  The old definitions of
MOD and DIV:

   MOD   |- MOD k n = @r. ?q. (k = (q * n) + r) /\ r < n
   DIV   |- DIV k n = @q. (k = (q * n) + (k MOD n))

have been deleted, and replaced by the constant specification:

   DIVISION |- !n. 0 < n ==> 
   		   (!k. (k = ((k DIV n) * n) + (k MOD n)) /\ (k MOD n) < n)

the validity of which is justified by the division algorithm:

   DA  |- !k n. 0 < n ==> (?r q. (k = (q * n) + r) /\ r < n)

The following theorems are also available:

  MOD_ONE      |- !k. k MOD (SUC 0) = 0

  DIV_LESS_EQ  |- !n. 0 < n ==> (!k. (k DIV n) <= k)

  DIV_UNIQUE   |- !n k q. (?r. (k = (q * n) + r) /\ r < n) ==> (k DIV n = q)

  MOD_UNIQUE   |- !n k r. (?q. (k = (q * n) + r) /\ r < n) ==> (k MOD n = r)

  DIV_MULT     |- !n r. r < n ==> (!q. ((q * n) + r) DIV n = q)

  LESS_MOD     |- !n k. k < n ==> (k MOD n = k)

  MOD_EQ_0     |- !n. 0 < n ==> (!k. (k * n) MOD n = 0)

  ZERO_MOD     |- !n. 0 < n ==> (0 MOD n = 0)

  MOD_MULT     |- !n r. r < n ==> (!q. ((q * n) + r) MOD n = r)

  MOD_TIMES    |- !n. 0 < n ==> (!q r. ((q * n) + r) MOD n = r MOD n)

  MOD_PLUS     |- !n. 0 < n ==> 
  		      (!j k. ((j MOD n) + (k MOD n)) MOD n = (j + k) MOD n)

  MOD_MOD      |- !n. 0 < n ==> (!k. (k MOD n) MOD n = k MOD n)

Other built-in theorems may be added in later releases of HOL.


+----------------------------------------------------------------------------+
| CHANGE TYPE:   Deletions ("form" syntax functions)   			     |
|----------------------------------------------------------------------------|
| CHANGED BY:    TFM                                                         |
|----------------------------------------------------------------------------|
| FILES CHANGED: lisp/f-ol-syntax.l lisp/f-subst.l lisp/f-inst.l	     |
|		 (+ REFERENCE manual)		     		             |
|----------------------------------------------------------------------------|
| DATE:          27 May 1990                                                 |
+----------------------------------------------------------------------------+

The functions

    form_class
    form_frees
    form_vars
    form_tyvars

are used nowhere in HOL, and their definitions has therefore been deleted 
(commented-out, actually).  The preliminary REFERENCE manual entries for 
these functions have also been deleted.

+----------------------------------------------------------------------------+
| CHANGE TYPE:   Deletion of redundant arithmetic theorem.		     |
|----------------------------------------------------------------------------|
| CHANGED BY:    TFM                                                         |
|----------------------------------------------------------------------------|
| FILES CHANGED: theories/mk_arith_thms.ml				     |
|----------------------------------------------------------------------------|
| DATE:          31 May 1990                                                 |
+----------------------------------------------------------------------------+

The built-in theorems:

  LESS_SUC_EQ  |- !m n. m < n ==> (SUC m) <= n 

  LESS_OR      |- !m n. m < n ==> (SUC m) <= n

are identical.  The theorem LESS_SUC_EQ has therefore been deleted, and all
references to it replaced by references to LESS_OR.  Its REFERENCE manual
entry has also been deleted.

+----------------------------------------------------------------------------+
| CHANGE TYPE:   Deletion (relocation) of general ML functions.		     |
|----------------------------------------------------------------------------|
| CHANGED BY:    TFM                                                         |
|----------------------------------------------------------------------------|
| FILES CHANGED: ml/genfns.ml						     |
|----------------------------------------------------------------------------|
| DATE:          31 May 1990                                                 |
+----------------------------------------------------------------------------+

The built-in ML functions:

   seg:(int#int)->(*)list->(*)list 					
   word_seg:(int#int)->(*)list->(*)list 				 
   word_el:int->(*)list->*						
   truncate:int->(*)list->(*)list					

have been moved into the eval library, and are no therefore longer available
in the basic system.

+----------------------------------------------------------------------------+
| CHANGE TYPE:   Bugfix: compiled sections.				     |
|----------------------------------------------------------------------------|
| CHANGED BY:    TFM                                                         |
|----------------------------------------------------------------------------|
| FILES CHANGED: lisp/f-tml.l						     |
|----------------------------------------------------------------------------|
| DATE:          1 June 1990						     |
+----------------------------------------------------------------------------+

ML compiler fixed so that sections (not for general use) will compile
properly.

+----------------------------------------------------------------------------+
| CHANGE TYPE:   Modified failure string (GEN_TAC).			     |
|----------------------------------------------------------------------------|
| CHANGED BY:    TFM                                                         |
|----------------------------------------------------------------------------|
| FILES CHANGED: ml/tactics.ml						     |
|----------------------------------------------------------------------------|
| DATE:          2 June 1990.						     |
+----------------------------------------------------------------------------+

The tactic GEN_TAC now fails with a more informative failure string.

|----------------------------------------------------------------------------|
| CHANGE TYPE:   New ML type (preterm) and function (preterm_to_term)        |
|----------------------------------------------------------------------------|
| CHANGED BY:    MJCG                                                        |
|----------------------------------------------------------------------------|
| FILES CHANGED: lisp/f-typeol.l       	                                     |
|                ml/hol-syn.ml         					     |
|----------------------------------------------------------------------------|
| DATE:          2 June 1990                                                 |
|----------------------------------------------------------------------------|

The ML abstract type `preterm' represents the parse trees of HOL
terms. It is intended to provide the input type to user programmed HOL
typecheckers (see the descriptions of the function preterm_handler
below). The definition of preterm is:


rectype preterm = var      of string                       % Variables       %
                | const    of string                       % Constants       %
                | comb     of preterm # preterm            % Combinations    %
                | abs      of preterm # preterm            % Abstractions    %
                | typed    of preterm # type               % Explicit typing %
                | antiquot of term;;                       % Antiquotation   %

Users should note that this definition makes the ML identifiers var, const,
comb, abs, typed, and antiquot unavailable for other uses.

The function:

   preterm_to_term : preterm -> term

invokes the standard HOL typechecker on a preterm and returns the
resulting typechecked term (or causes the standard error message).



|----------------------------------------------------------------------------|
| CHANGE TYPE:   Change to HOL top level: user definable HOL typechecking    |
|----------------------------------------------------------------------------|
| CHANGED BY:    MJCG                                                        |
|----------------------------------------------------------------------------|
| FILES CHANGED: lisp/f-typeol.l       	                                     |
|                lisp/f-parsml.l                                             |
|----------------------------------------------------------------------------|
| DATE:          2 June 1990                                                 |
|----------------------------------------------------------------------------|

The typechecker for HOL quotations contains a number of arbitrary
design decisions. Several people have suggested changes, e.g. that
full Milner/Hindley type inference be performed. Rather than try to
create a single new improved typechecker, a facility is now provided
that enables the user to write his or her own one and then to install
it in the system.

A typechecker is a function of type preterm->term. If the flag
`preterm' is set to true (the default is false), then HOL will use
whatever ML function is currently bound to the name preterm_handler as
the quotation typechecker. The way this works is that when `preterm'
is true the parser produces a preterm rather than a term, and then
wraps a call of preterm_handler around the quotation.

Example
-------

   #letref p_reg = var `x`;;
   p_reg = var`x` : preterm

   #let preterm_handler p = p_reg:=p; preterm_to_term p;;
   preterm_handler = - : (preterm -> term)

   #set_flag(`preterm`,true);;
   false : bool

   #"x+y";;
   "x + y" : term

   #p_reg;;
   comb((comb((const`+`), var`x`)), var`y`) : preterm

   #"x x";;
   Badly typed application of:  "x"
      which has type:           ":?"
   to the argument term:        "x"
      which has type:           ":?"

   evaluation failed     mk_comb

   #p_reg;;
   comb((var`x`), var`x`) : preterm

   #"!x.?y. x<y";;
   "!x. ?y. x < y" : term

   #p_reg;;
   comb((const`!`),
        abs((var`x`),
            comb((const`?`),
                 abs((var`y`), comb((comb((const`<`), var`x`)), var`y`)))))
   : preterm

+----------------------------------------------------------------------------+
| CHANGE TYPE:   Deletions (redunant syntax functions)   		     |
|----------------------------------------------------------------------------|
| CHANGED BY:    TFM                                                         |
|----------------------------------------------------------------------------|
| FILES CHANGED: lisp/f-subst.l lisp/f-inst.l ml/hol-syn.ml		     |
|----------------------------------------------------------------------------|
| DATE:          4 June 1990.						     |
+----------------------------------------------------------------------------+

In previous versions, the built-in functions:

   term_frees
   term_vars
   term_tyvars

were unnecessary synonyms for the functions frees, vars and tyvars.  The
functions term_frees, term_vars and term_tyvars (and their REFERENCE entries)
have therefore been deleted from the system.

+----------------------------------------------------------------------------+
| CHANGE TYPE:   Deletion (ml function term_class)			     |
|----------------------------------------------------------------------------|
| CHANGED BY:    TFM                                                         |
|----------------------------------------------------------------------------|
| FILES CHANGED: lisp/f-ol-syntax.l					     |
|----------------------------------------------------------------------------|
| DATE:          5 June 1990						     |
+----------------------------------------------------------------------------+

The function term_class is used nowhere in HOL88. Its definition has therefore
been commented-out and its REFERENCE manual entry deleted.

+----------------------------------------------------------------------------+
| CHANGE TYPE:   Hiding of local functions.		     		     |
|----------------------------------------------------------------------------|
| CHANGED BY:    TFM                                                         |
|----------------------------------------------------------------------------|
| FILES CHANGED: ml/hol-syn.ml						     |
|----------------------------------------------------------------------------|
| DATE:          5 June 1990.						     |
+----------------------------------------------------------------------------+

The following ML functions, which are required only for internal use, have 
been made local in the ML file hol-syn.ml.  They are therefore no longer 
available at the top-level of HOL.

   new_pp_theory
   close_pp_theory
   load_pp_theory
   extend_pp_theory

The REFERENCE manual entries for these functions have been deleted.

+----------------------------------------------------------------------------+
| CHANGE TYPE:   bug fix (close_theory).				     |
|----------------------------------------------------------------------------|
| CHANGED BY:    TFM                                                         |
|----------------------------------------------------------------------------|
| FILES CHANGED: ml/hol-syn.ml						     |
|----------------------------------------------------------------------------|
| DATE:          5 June 1990.						     |
+----------------------------------------------------------------------------+

The function close_theory has been modified to have the ML type specified for
it in the documentation:

   close_theory : void -> void

This function used to have type * -> void, but can now be applied only to the
value of type void --- i.e. to ().

+----------------------------------------------------------------------------+
| CHANGE TYPE:   optimization (ALPHA_CONV).				     |
|----------------------------------------------------------------------------|
| CHANGED BY:    TFM                                                         |
|----------------------------------------------------------------------------|
| FILES CHANGED: ml/drul.ml						     |
|----------------------------------------------------------------------------|
| DATE:          12 June 1990.						     |
+----------------------------------------------------------------------------+

The built-in inference rule ALPHA_CONV has been optimized for speed.  It now
runs in approx .625 times the CPU time used by the old version.  Users should
notice no difference in functionality.

+----------------------------------------------------------------------------+
| CHANGE TYPE:   Revised conversion: EXISTS_UNIQUE_CONV.    		     |
|----------------------------------------------------------------------------|
| CHANGED BY:    TFM                                                         |
|----------------------------------------------------------------------------|
| FILES CHANGED: ml/conv.ml						     |
|----------------------------------------------------------------------------|
| DATE:          12 June 1990.						     |
+----------------------------------------------------------------------------+

The built-in conversion EXISTS_UNIQUE_CONV is used to expand with the
definition of unique existence.  In previous versions of HOL, the conversion
was defined such that EXISTS_UNIQUE_CONV "?!z.P[z]" yielded the theorem: 

   |- ?!z.P[z] = ?z.P[z] /\ !x y. P[x] /\ P[y] ==> (x=y)

Note that the variables "x" and "y" in this result were always just "x" and
"y"---the fact that the input term used the variable "z" wasn't taken into
account.  This could result in some confusing theorems.  For example:

   EXISTS_UNIQUE_CONV  "?! f. !x. f x = x" 

would give:

   |- (?! f. !x. f x = x) =
      (?f. !x. f x = x) /\
      (!x y. (!x. x x = x) /\ (!x. y x = x) ==> (x = y))

Note the confusing double use of "x" in the second conjunct.

The new EXISTS_UNIQUE_CONV in version 1.12 solves this problem by making:

   EXISTS_UNIQUE_CONV "?!z.P[z]" 

yield the theorem:

   |- ?!z.P[z] = ?z.P[z] /\ !z z'. P[z] /\ P[z'] ==> (z=z')

where z' is a primed variant of z which does not occur in P[z].  The result is
a theorem which is logically equivalent, but which contains less suprising
bound variable names.


+----------------------------------------------------------------------------+
| CHANGE TYPE:   Modified printing of goals.		     		     |
|----------------------------------------------------------------------------|
| CHANGED BY:    RJB                                                         |
|----------------------------------------------------------------------------|
| FILES CHANGED: ml/goals.ml						     |
|----------------------------------------------------------------------------|
| DATE:          6  June 1990                                                |
+----------------------------------------------------------------------------+

Assignable variable added so that a user-specified term-printing function
can be used for printing goals:

   letref assignable_print_term = print_term;;

References to `print_term' in the definitions of `print_hyps' and `print_goal'
changed to read `assignable_print_term'.

+----------------------------------------------------------------------------+
| CHANGE TYPE:   Rewrite of built-in function: INDUCT_THEN		     |
|----------------------------------------------------------------------------|
| CHANGED BY:	 TFM							     |
|----------------------------------------------------------------------------|
| FILES CHANGED: ml/ind.ml						     |
|----------------------------------------------------------------------------|
| DATE:          16 June 1990.						     |
+----------------------------------------------------------------------------+

The built-in general induction tactic INDUCT_THEN has been reorganized and
rewritten.  Users should notice no difference in functionality except the
that which is illustrated by the following example.

Suppose we define a type of binary trees by:

  let ax = define_type `btree` `btree = L | N btree btree`;;

and then prove the correpsonding induction theorem:

  ind = |- !P. P L /\ (!b b'. P b /\ P b' ==> P(N b b')) ==> (!b. P b)

Now suppose we have the goal:

  "B:btree. P[B]"

and we wish to use the tactic INDUCT_THEN ind ASSUME_TAC on this goal.  With
the old version of induction, the resulting subgoals would be:

  1:  "P L"      and      2:  "P(N B b')"
                                 [ "P B" ]
                                 [ "P b'" ]

Note that in subgoal 2, the variable ranging over trees in the first induction
hypothesis is "B" --- the same variable as was in our original goal.  But the
corresponding variable in the second hypothesis is "b'". This variable came
from the original induction theorem, and, unlike the variable "B" in the first
hypthesis, does not reflect the user's preference of variable names.

The new version of INDUCT_THEN removes this anomaly.  With the new version,
the subgoals generated for the example shown above would be:

  1:  "P L"      and      2:  "P(N B B')"
                                 [ "P B" ]
                                 [ "P B'" ]

which corresponds more closely to the users choice of variable names.

It is possible that this change to INDUCT_THEN will make existing proofs fail.

+----------------------------------------------------------------------------+
| CHANGE TYPE:   Hiding of local function.		     		     |
|----------------------------------------------------------------------------|
| CHANGED BY:    TFM                                                         |
|----------------------------------------------------------------------------|
| FILES CHANGED: ml/hol-thyfn.ml ml/lis.ml				     |
|----------------------------------------------------------------------------|
| DATE:          25 June 1990                                                |
+----------------------------------------------------------------------------+

The following ml function, which is required only internally, has been
made local in the file hol-thyfn.ml:

    upto

This function are no longer available at top-level, and its preliminary
REFERENCE manual entries have been deleted.

+----------------------------------------------------------------------------+
| CHANGE TYPE:   Optimiztions.						     |
|----------------------------------------------------------------------------|
| CHANGED BY:    TFM                                                         |
|----------------------------------------------------------------------------|
| FILES CHANGED: ml/hol-rule.ml ml/hol-drule.ml				     |
|----------------------------------------------------------------------------|
| DATE:          27 June 1990                                                |
+----------------------------------------------------------------------------+

The built-in inference rules: ABS and FORALL_EQ have been very slightly
optimized for speed.  Users should notice no difference in functionality.

+----------------------------------------------------------------------------+
| CHANGE TYPE:   New logic theorems.					     |
|----------------------------------------------------------------------------|
| CHANGED BY:    TFM                                                         |
|----------------------------------------------------------------------------|
| FILES CHANGED: ml/hol-drule.ml + REFERENCE manual.			     |
|----------------------------------------------------------------------------|
| DATE:          27 June 1990                                                |
+----------------------------------------------------------------------------+

The following new logic theorems are now built-in:

   OR_IMP_THM    |- !t1 t2. (t1 = t2 \/ t1) = t2 ==> t1
   NOT_IMP       |- !t1 t2. ~(t1 ==> t2) = t1 /\ ~t2
   COND_ID       |- !b t. (b => t | t) = t

REFERENCE manual entries have been added for these theorems.

+----------------------------------------------------------------------------+
| CHANGE TYPE:   Rewrite of prove_induction_thm				     |
|----------------------------------------------------------------------------|
| CHANGED BY:    TFM                                                         |
|----------------------------------------------------------------------------|
| FILES CHANGED: ml/tyfns.ml						     |
|----------------------------------------------------------------------------|
| DATE:          29 June 1990						     |
+----------------------------------------------------------------------------+

The built-in proof procedure:

    prove_induction_thm

has been totally rewritten.  Its code is now better structured and documented,
and the function itself takes about 0.5 times the amount of time used by the 
previous version.  Users should notice no difference in functionality.


+----------------------------------------------------------------------------+
| CHANGE TYPE:   Rewrite of prove_constructors_distinct			     |
|----------------------------------------------------------------------------|
| CHANGED BY:    TFM                                                         |
|----------------------------------------------------------------------------|
| FILES CHANGED: ml/tyfns.ml						     |
|----------------------------------------------------------------------------|
| DATE:          29 June 1990						     |
+----------------------------------------------------------------------------+

The built-in proof procedure:

    prove_constructors_distinct

has been largely rewritten.  Its code is now better structured and documented
and uses a slightly different algorithm.  The only difference in functionality
is that prove_constructors_distinct now returns a theorem without
unnecessarily primed variables.  

The change is best illustrated by an example.  If we define:

    let th = define_type 
    	     `five` `five = A num | B num | C num | D num | E num`;;

then executing the old version of prove_constructors_distinct:

   let old = prove_constructors_distinct th;;		% old version %

would return:

   old = |- (!n n'. ~(A n = B n')) /\
            (!n n''. ~(A n = C n'')) /\
            (!n n'''. ~(A n = D n''')) /\
            (!n n''''. ~(A n = E n'''')) /\
            (!n' n''. ~(B n' = C n'')) /\
            (!n' n'''. ~(B n' = D n''')) /\
            (!n' n''''. ~(B n' = E n'''')) /\
            (!n'' n'''. ~(C n'' = D n''')) /\
            (!n'' n''''. ~(C n'' = E n'''')) /\
            (!n''' n''''. ~(D n''' = E n''''))

Note the annoying extra "primes" on the n's.  The new implementation, on the
other hand, does less unnecessary priming.  Executing:

   let new = prove_constructors_distinct th;;		% new version %

will now return:

   new = |- (!n n'. ~(A n = B n')) /\
            (!n n'. ~(A n = C n')) /\
            (!n n'. ~(A n = D n')) /\
            (!n n'. ~(A n = E n')) /\
            (!n n'. ~(B n = C n')) /\
            (!n n'. ~(B n = D n')) /\
            (!n n'. ~(B n = E n')) /\
            (!n n'. ~(C n = D n')) /\
            (!n n'. ~(C n = E n')) /\
            (!n n'. ~(D n = E n'))

Users may be interested to note that the unnecessary priming was due to the 
following behaviour of the primitive operation "subst":

   #let tm = subst ["n:num","m:num"] "!n:num. n = n";;
   tm = "!n'. n' = n'" : term

Note that the n gets unnecessarily primed.

+----------------------------------------------------------------------------+
| CHANGE TYPE:   Hiding of local function. (GSUBS)	     		     |
|----------------------------------------------------------------------------|
| CHANGED BY:    TFM                                                         |
|----------------------------------------------------------------------------|
| FILES CHANGED: ml/hol-drule.ml					     |
|----------------------------------------------------------------------------|
| DATE:          2 July 1990						     |
+----------------------------------------------------------------------------+

The function GSUBS has been made local in the file hol-drule.ml, and is no
longer available at top-level.  The REFERENCE entry has been deleted.

+----------------------------------------------------------------------------+
| CHANGE TYPE:   Bugfix							     |
|----------------------------------------------------------------------------|
| CHANGED BY:    TFM                                                         |
|----------------------------------------------------------------------------|
| FILES CHANGED: ml/conv.ml						     |
|----------------------------------------------------------------------------|
| DATE:          3 July 1990						     |
+----------------------------------------------------------------------------+

The built-in conversions NOT_FORALL_CONV and NOT_EXISTS_CONV have been
rewritten to fix the bugs illustrated by:

   #NOT_FORALL_CONV "~ !x:num.T";;
   evaluation failed     NOT_FORALL_CONV

   #NOT_EXISTS_CONV "~ ?x:num.T";;
   evaluation failed     IMP_ANTISYM_RULE

I.e. they didn't work when the quantified variable did not actually occur free
in the body of the formula.  This bug has been fixed.

These two conversions have also been optimized for speed; they now run in less
than 1/3 the time they used to take.

+----------------------------------------------------------------------------+
| CHANGE TYPE:   Rewrite of prove_cases_thm				     |
|----------------------------------------------------------------------------|
| CHANGED BY:    TFM                                                         |
|----------------------------------------------------------------------------|
| FILES CHANGED: ml/tyfns.ml						     |
|----------------------------------------------------------------------------|
| DATE:          9 July 1990						     |
+----------------------------------------------------------------------------+

The built-in proof procedure:

    prove_cases_thm

has been totally rewritten.  Its code is now (much!) better structured and
documented, and the function itself takes about 0.6 times (or less) the amount
of time used by the previous version.  Users should notice no difference in
functionality.

+----------------------------------------------------------------------------+
| CHANGE TYPE:   Bugfix (REWRITE_CONV)					     |
|----------------------------------------------------------------------------|
| CHANGED BY:    TFM                                                         |
|----------------------------------------------------------------------------|
| FILES CHANGED: ml/conv.ml						     |
|----------------------------------------------------------------------------|
| DATE:          12 July 1990						     |
+----------------------------------------------------------------------------+

In previous versions of HOL, the rewriting primitive REWRITE_CONV would 
occasionally behave as follows:

   REWRITE_CONV   |- u = v    "t"

would return a theorem |- u' = v', where "u'" is alpha-equivalent to "t"
rather than syntactically identical to "t" (most users will not have noticed
this problem).  REWRITE_CONV has been modified, such that

   REWRITE_CONV   |- u = v    "t"

returns |- t = t', where t is alpha-equivalent to a substitution instance of
u and t' is the corresponding instance of v.

+----------------------------------------------------------------------------+
| CHANGE TYPE:   Rewrite of prove_constructors_one_one			     |
|----------------------------------------------------------------------------|
| CHANGED BY:    TFM                                                         |
|----------------------------------------------------------------------------|
| FILES CHANGED: ml/tyfns.ml						     |
|----------------------------------------------------------------------------|
| DATE:          12 July 1990
+----------------------------------------------------------------------------+

The built-in proof procedure:

    prove_constructors_one_one

has been largely rewritten.  Its code is now better structured and documented.
Users should notice no difference in functionality.

+----------------------------------------------------------------------------+
| CHANGE TYPE:   Hiding/deletion of local functions.	     		     |
|----------------------------------------------------------------------------|
| CHANGED BY:    TFM                                                         |
|----------------------------------------------------------------------------|
| FILES CHANGED: ml/tyfns.ml						     |
|----------------------------------------------------------------------------|
| DATE:          13 July 1990.						     |
+----------------------------------------------------------------------------+

A side-effect of rewriting the built-in functions for deriving facts about
recursive types (see above) is that the following functions, which were used
only internally, are no longer available at top level:

	DEPTH_EXISTS_CONV
	DISJS_CONV
	BINOP_CONV
	ANTE_FORALL_CONV
	make_tuple
	list_variant

The REFERENCE manual entries for these functions have been deleted.

+----------------------------------------------------------------------------+
| CHANGE TYPE:   new syntax functions: mk_let, dest_let, is_let		     |
|----------------------------------------------------------------------------|
| CHANGED BY:    TFM                                                         |
|----------------------------------------------------------------------------|
| FILES CHANGED: ml/hol-syn.ml						     |
|----------------------------------------------------------------------------|
| DATE:          17 July 1990.						     |
+----------------------------------------------------------------------------+

The following syntax functions have been added to the system:

   dest_let      which does: dest_let "LET f x"      ---> ("LET","f","x")

   mk_let        which does: mk_let ("LET","f","x")  ---> "LET f x"

   is_let        which is equivalent to can o dest_let

REFERENCE manual entries have been added.

+----------------------------------------------------------------------------+
| CHANGE TYPE:   new conversion: COND_CONV				     |
|----------------------------------------------------------------------------|
| CHANGED BY:    TFM                                                         |
|----------------------------------------------------------------------------|
| FILES CHANGED: ml/conv.ml						     |
|----------------------------------------------------------------------------|
| DATE:          23 July 1990.						     |
+----------------------------------------------------------------------------+

A new conversion for simplifying conditionals, called COND_CONV, has been
added to the system.  The conversion has the following specification:

									
   ------------------------- COND_CONV "T => u | v"
     |- (T => u | v) = u

									
   ------------------------- COND_CONV "F => u | v"			
     |- (F => u | v) = v


   ------------------------- COND_CONV "b => u | u"
     |- (b => u | u) = u 

A call to COND_CONV "P=>u|v" fails unless P = T or P = F or u = v.  

+----------------------------------------------------------------------------+
| CHANGE TYPE:   new conversion: PAIRED_BETA_CONV			     |
|----------------------------------------------------------------------------|
| CHANGED BY:    TFM                                                         |
|----------------------------------------------------------------------------|
| FILES CHANGED: ml/conv.ml						     |
|----------------------------------------------------------------------------|
| DATE:          23 July 1990.						     |
+----------------------------------------------------------------------------+

A new conversion called PAIRED_BETA_CONV has been added to do generalized beta
conversion of tupled lambda abstractions applied to tuples (i.e. redexes).

Given the term:                                    			
                                                                       
   "(\(x1, ... ,xn).t) (t1, ... ,tn)"                                	
                                                                       
PAIRED_BETA_CONV proves that:						
                                                                       
   |- (\(x1, ... ,xn).t) (t1, ... ,tn) = t[t1, ... ,tn/x1, ... ,xn]    

where t[t1,...,tn/x1,...,xn] is the result of substituting ti for xi in
parallel in t, with suitable renaming of variables to prevent free variables
in t1,...,tn becoming bound in the result.  

The conversion works for arbitrarily nested tuples.  For example:

    PAIRED_BETA_CONV "(\((a,b),(c,d)).t) ((1,2),(3,4))" 

gives: 

    |- (\((a,b),(c,d)).t) ((1,2),(3,4)) = t[1,2,3,4/a,b,c,d]

A preliminary REFERENCE manual entry has been added.

+----------------------------------------------------------------------------+
| CHANGE TYPE:   renaming						     |
|----------------------------------------------------------------------------|
| CHANGED BY:    TFM                                                         |
|----------------------------------------------------------------------------|
| FILES CHANGED: ml/conv.ml						     |
|----------------------------------------------------------------------------|
| DATE:          23 July 1990.						     |
+----------------------------------------------------------------------------+

BOOL_EQ_CONV has been renamed bool_EQ_CONV, which behaves as follows:

    bool_EQ_CONV "b1 = b2" returns:
 
        |- (b1 = b2) = T       if b1 and b2 are identical boolean terms
        |- (b1 = b2) = b2      if b1 = "T"
        |- (b1 = b2) = b1      if b2 = "T"

+----------------------------------------------------------------------------+
| CHANGE TYPE:   new conversion: ADD_CONV				     |
|----------------------------------------------------------------------------|
| CHANGED BY:    TFM                                                         |
|----------------------------------------------------------------------------|
| FILES CHANGED: ml/num.ml						     |
|----------------------------------------------------------------------------|
| DATE:          24 July 1990.						     |
+----------------------------------------------------------------------------+

If n and m are numerals (i.e 0,1,2,3,...) then:

      ADD_CONV "n + m" 

returns 

      |- n + m = s

where s is the numeral denoting the sum of n and m.  For example:

     ADD_CONV "1 + 2"       --->   |- 1 + 2 = 3
     ADD_CONV "0 + 1000"    --->   |- 0 + 1000 = 1000
     ADD_CONV "101 + 102"   --->   |- 101 + 102 = 203


NOTE: the conversion runs in O(min{n,m}) time, where n and m are the numbers
being added.  It runs out of stack for large numbers (more than 200 or so in
the Franz HOL).  A preliminary REFERENCE manual entry has been added.

+----------------------------------------------------------------------------+
| CHANGE TYPE:   new built-in arithmetic theorems			     |
|----------------------------------------------------------------------------|
| CHANGED BY:    TFM                                                         |
|----------------------------------------------------------------------------|
| FILES CHANGED: theories/mk_arith_thms.ml ml/load_theorems REFERENCE manual |
|----------------------------------------------------------------------------|
| DATE:          25 July 1990.						     |
+----------------------------------------------------------------------------+
 
The following are now available as built-in theorems in the system:


  ZERO_LESS_EQ       |- !n. 0 <= n
  LESS_EQ_MONO       |- !n m. (SUC n <= SUC m) = (n <= m)
  LESS_OR_EQ_ADD     |- !n m. n < m \/ ?p. n = p+m
  SUC_NOT            |- !n. ~(0 = SUC n)
  SUB_MONO_EQ	     |- !n m. (SUC n) - (SUC m) = n - m
  SUB_PLUS	     |- !a b c. a - (b + c) = (a - b) - c
  INV_PRE_LESS	     |- !m n. 0 < m /\ 0 < n ==> ((PRE m) < (PRE n) = m < n)
  INV_PRE_LESS_EQ    |- !n. 0 < n ==> !m. ((PRE m) <= (PRE n) = m <= n)
  SUB_LESS_EQ	     |- !n m. (n - m) <= n
  SUB_EQ_EQ_0	     |- !m n. (m - n = m) = (m = 0) \/ (n = 0)
  SUB_LESS_0	     |- !n m. m < n = 0 < (n - m)
  SUB_LESS_OR	     |- !m n. n < m ==> n <= (m - 1)
  LESS_SUB_ADD_LESS  |- !n m i. i < (n - m) ==> (i + m) < n
  TIMES2	     |- !n. 2 * n = n + n
  LESS_MULT_MONO     |- !m i n. ((SUC n) * m) < ((SUC n) * i) = m < i
  MULT_MONO_EQ	     |- !m i n. ((SUC n) * m = (SUC n) * i) = (m = i)
  ADD_SUB	     |- !a c. (a + c) - c = a
  LESS_EQ_ADD_SUB    |- !c b. c <= b ==> (!a. (a + b) - c = a + (b - c))
  SUB_EQUAL_0	     |- !c. c - c = 0
  LESS_EQ_SUB_LESS   |- !a b. b <= a ==> (!c. (a - b) < c = a < (b + c))
  NOT_SUC_LESS_EQ    |- !n m. ~(SUC n) <= m = m <= n
  SUB_SUB	     |- !b c. c <= b ==> (!a. a - (b - c) = (a + c) - b)
  LESS_IMP_LESS_ADD  |- !n m. n < m ==> (!p. n < (m + p))
  LESS_EQ_IMP_LESS_SUC |- !n m. n <= m ==> n < (SUC m)
  SUB_LESS_EQ_ADD    |- !m p. m <= p ==> (!n. (p - m) <= n = p <= (m + n))
  SUB_CANCEL	     |- !p n m. n <= p /\ m <= p ==> 
				((p - n = p - m) = (n = m))
  CANCEL_SUB	     |- !p n m. p <= n /\ p <= m ==> 
				((n - p = m - p) = (n = m))
  NOT_EXP_0	     |- !m n. ~((SUC n) EXP m = 0)
  ZERO_LESS_EXP	     |- !m n. 0 < ((SUC n) EXP m)
  ODD_OR_EVEN	     |- !n. ?m. (n = (SUC(SUC 0)) * m) \/ 
			        (n = ((SUC(SUC 0)) * m) + 1)
  LESS_EXP_SUC_MONO  |- !n m.((SUC(SUC m)) EXP n) < ((SUC(SUC m)) EXP (SUC n))

The REFERENCE manual has been updated with these theorems.

+----------------------------------------------------------------------------+
| CHANGE TYPE:   Modified failure strings.		     		     |
|----------------------------------------------------------------------------|
| CHANGED BY:    TFM                                                         |
|----------------------------------------------------------------------------|
| FILES CHANGED: ml/tactics.ml						     |
|----------------------------------------------------------------------------|
| DATE:          2 August 1990.						     |
+----------------------------------------------------------------------------+

The ML functions listed below now fail with the following failure strings:

   DISCH_TAC   fails with   `DISCH_TAC`   instead of   `DISCH_THEN`
   STRIP_TAC   fails with   `STRIP_TAC`   instead of   `FIRST`


+----------------------------------------------------------------------------+
| CHANGE TYPE:   Parser extension: set syntax                                |
|----------------------------------------------------------------------------|
| CHANGED BY:    MJCG                                                        |
|----------------------------------------------------------------------------|
| FILES CHANGED: lisp/parslist.l					     |
|                lisp/hol-writ.l					     |
|                lisp/genmacs.l 					     |
|                lisp/f-iox-stand.l 					     |
|----------------------------------------------------------------------------|
| DATE:          5 August 1990.						     |
| UPDATED:       12 November 1990.                                           |
+----------------------------------------------------------------------------+

The special purpose set-theoretic notations "{t1,t2, ... ,tn}" and
"{t | p}" are now available.

Finite Sets
-----------

Executing:

   define_finite_set_syntax(`name_1`,`name_2`);;

causes

   "{t1,...,tn}"

to parse to

   "name_1 t1 (name_1 t2 ... (name_1 tn name_2) ... ))"

Failure if either name_1 or name_2 is not the name of a constant.

For example:

   define_finite_set_syntax(`EMPTY`,`INSERT`);;

will cause

   "{1,2,3,4}"

to parse to

   "1 INSERT (2 INSERT (3 INSERT (4 INSERT EMPTY)))"


General set abstractions
------------------------

Executing:

   define_set_abstraction_syntax `name`;;

causes

   "{t | p }"

to parse to

   "name(\(x1,...,xn). (t, p))"

where "x1", ... , "xn" are the free variables occurring in both "t"
and "p".  If there are no such free variables then an error results.
The order in which the variables are listed in the variable structure
of the paired abstraction is an unspecified function of the structure
of "t" (it is approximately left to right). Failure if name is not the
name of a constant.

For example, if the library `sets` (i.e. what used to be `all_sets`-see below)
is loaded, then:

   define_set_abstraction_syntax `GSPEC`;;

will cause:

   "{x+y | (x < y) /\ (y < z)}"

to parse to:

   "GSPEC(\(x,y). ((x+y), (x < y) /\ (y < z)))"

and

   "{x+y+z | (x < y) /\ (y < z)}"

to parse to:

   "GSPEC(\(x,y,z). (x+(y+z), (x < y /\ y < z)))" 

and

   "{x+y+w | (x < y) /\ (y < z)}"

to parse to

   "GSPEC(\(x,y). (x+(y+w), (x < y /\ y < z)))"

Precedence
----------

The precedence of comma is increased in the contexts "{...}" and "{...|".


Printing of set notation
------------------------

Terms will be printed in set notation if the flag `print_set` is true. 

Note that "GSPEC(\(x1,...,xn).(t,p))" will only print as "{t|p}" (when
`print_set` is true) if the variables x1, ... , xn occur free in both
t and p.

+----------------------------------------------------------------------------+
| CHANGE TYPE:   Reorganized libraries: set, sets, all_sets.		     |
|----------------------------------------------------------------------------|
| CHANGED BY:    TFM							     |
|----------------------------------------------------------------------------|
| FILES CHANGED: Libraries/all_sets, Libraries/set, Libraries/sets	     |
|----------------------------------------------------------------------------|
| DATE:          7 August 1990.						     |
+----------------------------------------------------------------------------+

In previous versions of the system, there were three libraries dealing with
elementary set theory:

   sets     : a theory of finite sets (Windley and Leveilley)
   all_sets : a theory of infinite and finite sets (Windley and Leveilley)
   set      : a theory of predicates-as-sets (Kalker)

Each of these libraries is useful for certain applications, and all three will
therefore continue to be supported.  To better reflect the contents of these
libraries, they have been renamed as follows:

   sets     : is now called "finite_sets"
   all_sets : is now called "sets"
   set      : is now called "pred_sets"

See later entries in this file for further changes to these libraries.


+----------------------------------------------------------------------------+
| CHANGE TYPE:   Revised library ("sets" -- previously "all_sets")	     |
|----------------------------------------------------------------------------|
| CHANGED BY:    TFM							     |
|----------------------------------------------------------------------------|
| FILES CHANGED: Library/sets						     |
|----------------------------------------------------------------------------|
| DATE:          8 August 1990						     |
+----------------------------------------------------------------------------+

The sets library (formerly, "all_sets") has been extensively revised and
extended.  The library has been restructured, and several additional built-in
theorems are available.  Parser and pretty-printer support for the notation:

   {x1,...,xn}     = a finite set

   {x | P[x]}      = the set of all x such that P[x]

   {t[x] | P[x]}   = the set of all t[x] such that P[x]

is now provided by the parser/pretty-printer extension mentioned above in
MJCG's entry of 5 August.

Proof support is supplied for this notation in the form of a conversion called
SET_SPEC_CONV, which implements the axiom of specification for generalized set
specifications. SET_SPEC_CONV accepts two types of input:

 1) SET_SPEC_CONV "t IN {v | p[v]}"    (where v is a VARIABLE)

    this returns the theorem:
									
      |- t IN {v | p[v]} = p[t/v]


 2) SET_SPEC_CONV "t IN {tm[x1;...;xn] | p[x1;...xn]}"		
									
    this returns the theorem:
									
      |- t IN {tm[x1;...;xn] | p[x1;...xn]}
	   =								
         ?x1...xn. t = tm[x1;...;xn] /\ p[x1;...xn]			
									
Thus, for example, one can prove:

  * |- x IN {n | n < m} = x < m

  * |- 5 IN {x+y | x < 2 /\ y < 3} = ?x y. (5 = x + y) /\ x < 2 /\ y < 3


The library also makes available an induction principle for proving properties
of FINITE sets:


    "!s. FINITE s ==>  P[s]"                          			
   =============================     SET_INDUCT_TAC 			
    P[EMPTY]   P[x INSERT t]                         		
                  [ "FINITE t" ]                       			
		  [ "P[s]"]
                  [ "~x IN t"]                           		

The file Libaries/sets/COMPAT.READ.ME provides an index to theorem names in
the new library and other compatibility information. This is intended to help
users update proof scripts based on the old version of the all_sets library.

Users of the set theory library (in this revised version) are welcome to
contribute by suggesting theorems that might be added had to add to the basic
stock of built-in theorems provided by library. I will do my best to
incorporate these theorems (please also send the proofs) into the library.

+----------------------------------------------------------------------------+
| CHANGE TYPE:   New inference rules: ISPEC and ISPECL			     |
|----------------------------------------------------------------------------|
| CHANGED BY:    TFM							     |
|----------------------------------------------------------------------------|
| FILES CHANGED: ml/hol-drule.ml					     |
|----------------------------------------------------------------------------|
| DATE:          9 August 1990						     |
+----------------------------------------------------------------------------+

Two new inference rules, ISPEC and ISPECL, have been installed in the system.
These implement specialization of universally quantified theorems, and are
similar to the rules SPEC and SPECL.  The difference is that the new rules
type-instatiate the input theorem if necessary.  Thus:


        A |- !x:ty.tm							
   -----------------------   ISPEC "t:ty'" 
        A |- tm[t/x]							
									
where t is free for x in tm, and ty' is an instance of ty.  For example:

  ISPEC "1" |- !x:*.x=x     yields     |- 1=1

whereas

  SPEC "1" |- !x:*.x=x      

fails. The rule ISPECL is similar:

        A |- !x1...xn.tm						
   ---------------------------------   ISPECL ["t1",...,"tn"]		
       A |- tm[t1/x1,...,tn/xn]						

where each ti is free for xi in tm, and tm can be type instantiated such that
each xi has the same type as the corresponding ti.  Note that the required
type instantiations are done in parallel.  Thus:

  ISPECL ["x:*";"y:**"]  |- !a:**. !b:*. tm[a,b]

yields

  |- tm[x:*,y:**]

whereas

  ISPEC "y:**" (ISPEC "x:*"  |- !a:**. !b:*. tm[a,b])

yields

  |- tm[x:**,y:**]

Preliminary REFERENCE manual entries have been added for these functions.

+----------------------------------------------------------------------------+
| CHANGE TYPE:   New/moved built-in theorems.                                |
|----------------------------------------------------------------------------|
| CHANGED BY:    TFM							     |
|----------------------------------------------------------------------------|
| FILES CHANGED: ml/hol-drule.ml					     |
|----------------------------------------------------------------------------|
| DATE:          7 September 1990					     |
+----------------------------------------------------------------------------+

The built-in theorems DISJ_SYM and DE_MORGAN_THM have been removed from the
theory arithmetic. They are now simply bound to the ML identifiers DISJ_SYM
and DE_MORGAN_THM when the system is built.

A new theorem, DISJ_ASSOC:

   |- !t1 t2 t3. t1 \/ t2 \/ t3 = (t1 \/ t2) \/ t3 

is now also available.  The REFERENCE manual has been updated.

+----------------------------------------------------------------------------+
| CHANGE TYPE:   New inference rule (EQF_ELIM).			     	     |
|----------------------------------------------------------------------------|
| CHANGED BY:    TFM                                                         |
|----------------------------------------------------------------------------|
| FILES CHANGED: ml/hol-drule.ml					     |
|----------------------------------------------------------------------------|
| DATE:          7 September 1990.					     |
+----------------------------------------------------------------------------+

A new inference rule, EQF_ELIM:


    |- tm = F
   ------------
    |- ~tm

has been installed.  This rule is used for eliminating equality with "F".


+----------------------------------------------------------------------------+
| CHANGE TYPE:   New list theorems       				     |
|----------------------------------------------------------------------------|
| CHANGED BY:    TFM                                                         |
|----------------------------------------------------------------------------|
| FILES CHANGED: theories/mk_list_thms.ml ml/load_thms.ml                    |
|----------------------------------------------------------------------------|
| DATE:          7 September 1990.					     |
+----------------------------------------------------------------------------+

The following theorems are now available in the theory list:

 LIST_NOT_EQ: |- !l1 l2. ~(l1 = l2) ==> (!h1 h2. ~(CONS h1 l1 = CONS h2 l2))

 NOT_EQ_LIST: |- !h1 h2. ~(h1 = h2) ==> (!l1 l2. ~(CONS h1 l1 = CONS h2 l2))

 EQ_LIST      |- !h1 h2.
                 (h1 = h2) ==> 
                 (!l1 l2. (l1 = l2) ==> (CONS h1 l1 = CONS h2 l2))

+----------------------------------------------------------------------------+
| CHANGE TYPE:   New derived inference rules (conversions) for lists.        |
|----------------------------------------------------------------------------|
| CHANGED BY:    TFM                                                         |
|----------------------------------------------------------------------------|
| FILES CHANGED: ml/list.ml				                     |
|----------------------------------------------------------------------------|
| DATE:          8 September 1990.					     |
+----------------------------------------------------------------------------+

Two new conversions for lists are now built-in:

   LENGTH_CONV : computes the length of a list
   list_EQ_CONV: decision procedure for list equality

These functions behave as follows:

1) LENGTH_CONV: compute the length of a list                             
                                                                       
   A call to LENGTH_CONV "LENGTH[x1;...;xn]" returns:                    
                                                                       
      |- LENGTH [x1;...;xn] = n   where n is a numeral constant          


2) list_EQ_CONV: equality of lists. 
                                                                       
   This conversion proves or disproves the equality of two lists, given  
   a conversion for deciding the equality of elements.                   
                                                                         
   A call to:                                                            
                                                                         
      list_EQ_CONV conv "[x1;...;xn] = [y1;...;ym]"                      
                                                                         
   returns:                                                              
                                                                         
      |- ([x1;...;xn] = [y1;...;ym]) = F                                 
                                                                         
   if:                                                                   
                                                                         
      1: ~(n=m)  or 2: conv proves |- (xi = yi) = F for any 1<=i<=n,m    
                                                                         
   and:                                                                  
                                                                         
     |- ([x1;...;xn] = [y1;...;ym]) = T                                  
                                                                         
   if:                                                                   
                                                                         
      1: (n=m) and xi is syntactically identical to yi for 1<=i<=n,m, or 
      2: (n=m) and conv proves  |- (xi=yi)=T for 1<=i<=n,m               

Preliminary REFERENCE manual entries have been added for these functions.


+----------------------------------------------------------------------------+
| CHANGE TYPE:   Deletion: "keyword" facility. 				     |
|----------------------------------------------------------------------------|
| CHANGED BY:    TFM                                                         |
|----------------------------------------------------------------------------|
| FILES CHANGED: lisp/f-help.l 						     |
|----------------------------------------------------------------------------|
| DATE:          8 September 1990.					     |
+----------------------------------------------------------------------------+

The ML function "keyword" has been deleted, pending replacement by a more
sophisticated online index facility.  The REFERENCE manual has been updated.

+----------------------------------------------------------------------------+
| CHANGE TYPE:   Deletion: "obj" type and associated operations.             |
|----------------------------------------------------------------------------|
| CHANGED BY:    TFM                                                         |
|----------------------------------------------------------------------------|
| FILES CHANGED: lisp/f-obj.l lisp/f-constants.l lisp/mk-ml.l lisp/f-parsml.l|
|                lisp/f-typeml.l Makefile                                    |
|----------------------------------------------------------------------------|
| DATE:          8 September 1990.					     |
+----------------------------------------------------------------------------+

The built-in ML type obj, and the associated built-in functions:

   is_string : obj -> bool
   is_int    : obj -> bool
   is_cons   : obj -> bool

   obj_of_string : string -> obj
   obj_of_int    : int -> obj
   cons          : obj -> obj -> obj

   string_of_obj : obj -> string
   int_of_obj    : obj -> int

   left  : obj -> obj
   right : obj -> obj

   set_left  : obj -> obj -> obj
   set_right : obj -> obj -> obj

   eq : obj -> obj
   lisp_eval : obj -> obj

have, for the time being, been deleted from the system.  They may be 
reinstaned in future if a definite need for them is discovered.  The
manual has been updated accordingly.

+----------------------------------------------------------------------------+
| CHANGE TYPE:   Deletion: thenf, orelsef, etc. 			     |
|----------------------------------------------------------------------------|
| CHANGED BY:    TFM                                                         |
|----------------------------------------------------------------------------|
| FILES CHANGED: ml/gen.ml					             |
|----------------------------------------------------------------------------|
| DATE:          19 September 1990.					     |
+----------------------------------------------------------------------------+

The following functions have been deleted from the system:

 thenf
 orelsef
 all_fun
 no_fun
 first_fun
 every_fun
 repeatf
 
Their REFERENCE manual entries have also been deleted.


+----------------------------------------------------------------------------+
| CHANGE TYPE:   Bugfix (SPEC_ALL).					     |
|----------------------------------------------------------------------------|
| CHANGED BY:    TFM                                                         |
|----------------------------------------------------------------------------|
| FILES CHANGED: ml/drul.ml					             |
|----------------------------------------------------------------------------|
| DATE:          5 October 1990.					     |
+----------------------------------------------------------------------------+

The rule SPEC_ALL has been changed to:

  1) choose variables not free in the conclusion, as well as in the hyps.
  2) choose distinct variables.

The new code is:

% --------------------------------------------------------------------- %
% SPEC_ALL : thm -> thm							%
%									%
%     A |- !x1 ... xn. t[xi]						%
%    ------------------------   where the xi' are distinct 		%
%        A |- t[xi'/xi]		and not free in the input theorem	%
%									%
% BUGFIX: added the "distinct" part and code to make the xi's not free  %
% in the conclusion !x1...xn.t[xi].		        [TFM 90.10.04]	%
%									%
% OLD CODE:								%
% 									%
% let SPEC_ALL th =							%
%     let vars,() = strip_forall(concl th) in				%
%     SPECL (map (variant (freesl (hyp th))) vars) th;;			%
% --------------------------------------------------------------------- %

let SPEC_ALL =
    let f v (vs,l) = let v' = variant vs v in (v'.vs,v'.l) in
    \th. let hvs,con = (freesl # I) (dest_thm th) in
         let fvs = frees con and vars = fst(strip_forall con) in
         SPECL (snd(itlist f vars (hvs @ fvs,[]))) th;;

This prevents behaviour like:

   % thm1 = |- !n n'. n + n' = n' + n					%
   let thm1 = GEN_ALL (SPECL ["n:num";"n':num"] ADD_SYM);;

   % thm2 = . |-  n' + n' = n' + n'					%
   let thm2 = SPEC_ALL (ADD_ASSUM "n = 1" thm1);;

The preliminary REFERENCE entry for SPEC_ALL has been updated.

+----------------------------------------------------------------------------+
| CHANGE TYPE:   Rewrite (define_type).					     |
|----------------------------------------------------------------------------|
| CHANGED BY:    TFM                                                         |
|----------------------------------------------------------------------------|
| FILES CHANGED: ml/tydefs.ml theories/mk_tydefs.ml			     |
|----------------------------------------------------------------------------|
| DATE:          6 October 1990.					     |
+----------------------------------------------------------------------------+

The code for built-in function define_type has been totally rewritten.  The 
main visible changes are the following:

  1) define_type now as a proper parser for its input. The syntax of types
     accepted by define_type is now identical to that of logical types in
     quotations (please report discrepancies to TFM).  For example, the 
     old version of define_type would not parse:

       define_type <name> `ty = C num # num list`

     because of the spaces in the type `num # num list`.  The new version,
     however, ignores all spaces (line feeds, tabs, carrage returns, 
     form feeds) in the input grammar.  Furthermore, the new version 
     observes the standard precedences of type operators.  For example,
     the old version of define_type would parse:

       define_type <name> `ty = C num#num+bool->one`

     such that `num#num+bool->one` was interpreted as:

       ":num # (num + (bool -> one))"

     I.e. all infix type operators have equal precedence, and associate
     to the right.  The new version, however, parses `num#num+bool->one`
     into the type:

       ":((num # num) + bool) -> one"

     as required.  The new parser also has better error messages. (Please
     report instances of confusion to TFM).

  2) define_type has better error messages in general.

  3) define_type now fails if the constructors in the user-supplied 
     grammar are already constants, rather than generating primed names.

  4) the names and order of quantification for some of the variables
     in the resulting theorem differ slightly.  In the previous version,
     we get:

       |- !e f. ?!fn. 
           (fn C1 = e) /\ (!n t t'. fn(C2 t n t') = f(fn t)(fn t')n t t')

     in response to:

       define_type `ty` `ty = C1 | C2 ty num ty`;;

     But in the new version, "t1" and "t2" are used instead of "t" and "t'",
     and the order of quantification in the second conjunct is:

       !t1 n t2. fn(C2 t1 n t2) = f(fn t1)(fn t2)n t1 t2

     This change may cause existing tactic proofs not to run, particularly
     if they are sensitive to variable name changes (which is not a good
     idea in general).

  5) There is much better internal documentation (users interested in 
     tool-building may like to have a look).

  6) The new version of define_type runs in about half the time taken
     by the previous version.

The REFERENCE manual and DESCRIPTION will be updated to reflect these changes.


+----------------------------------------------------------------------------+
| CHANGE TYPE:   Deletions						     |
|----------------------------------------------------------------------------|
| CHANGED BY:    TFM                                                         |
|----------------------------------------------------------------------------|
| FILES CHANGED: ml/tydefs.ml 					  	     |
|----------------------------------------------------------------------------|
| DATE:          6 October 1990.					     |
+----------------------------------------------------------------------------+

A consequence of the rewrite of define_type (see above) is that the following
ML functions, which were never intended for general use, are no longer 
available at top-level:

BETA_RED_CONV		LENGTH_MAP_CONV		make_definitions
BINDER_CONV		LEN_SIMP_CONV		mk_def
CHOOSE_RULE		LHS_CONV		mk_defs
COND_F			MAP_ELIM		mk_fn_ty
COND_T			MOVE_FORALL_IN		mk_fun_test
CONJS_CONV		OR_ELIM_CONV		mk_funct
DEPTH_FORALL_CONV	OR_IMP			mk_injs
DO_ASM			PROJ			mk_new_vars
ELIM_ANTE_EQNS_CONV	RM_LEN_CONV		mk_subset_pred
ELIM_ANTE_EQN_CONV	SIMP_CONV		mk_sum_ty
ELIM_LEN_CONV		SIMP_ISL1		mk_test
ELIM_MAP_CONV		SIMP_ISL2		mk_tl_spec
EQ_ANTE_ELIM		SIMP_RHS		mk_tuple_ty
EXISTS_RULE		TEST_CONV		pars_ty
E_I_CONV		clean			parse_type
FN_BETA			cleanup			proj
FN_CASES_SIMP		do_abs			prove_existence_thm
FN_CASE_SIMP		extract_list		strip_cases
FORALL_AND_CONV		extract_tuple		strip_tok
FORALL_CONJ_CONV	gen_names		strip_val
FOUR_BINDER_CONV	infix_ty		strip_vty_tok
FST_SND_SIMP		is_char			sub_conv
HD_TL_SIMP		list_gen_alpha		ty_case
			variant_tyvar

The preliminary REFERENCE manual entries for these functions have been 
deleted.

+----------------------------------------------------------------------------+
| CHANGE TYPE:   Optimization.						     |
|----------------------------------------------------------------------------|
| CHANGED BY:    TFM                                                         |
|----------------------------------------------------------------------------|
| FILES CHANGED: ml/conv.ml						     |
|----------------------------------------------------------------------------|
| DATE:          10 October 1990.					     |
+----------------------------------------------------------------------------+

The conversion function ONCE_DEPTH_CONV has been rewritten to avoid rebuilding
unchanged subterms by using failure-trapping when searching terms.  The main
visible effect is that users will find the rewriting tactics and rules:

    ONCE_REWRITE_TAC		ONCE_REWRITE_RULE
    PURE_ONCE_REWRITE_TAC 	PURE_ONCE_REWRITE_RULE
    ONCE_ASM_REWRITE_TAC	ONCE_ASM_REWRITE_RULE
    PURE_ONCE_ASM_REWRITE_TAC	PURE_ONCE_ASM_REWRITE_RULE

will sometimes run MUCH faster than they used to (particularly when
there are only a few subterms that are to be rewritten, and these 
are deeply buried towards the lower right of a large term).

+----------------------------------------------------------------------------+
| CHANGE TYPE:   Modified failure strings.		     		     |
|----------------------------------------------------------------------------|
| CHANGED BY:    TFM                                                         |
|----------------------------------------------------------------------------|
| FILES CHANGED: ml/genfns.ml						     |
|----------------------------------------------------------------------------|
| DATE:          13 October 1990.				             |
+----------------------------------------------------------------------------+

The ML functions map2 and itlist2 now fail with `map2` and `itlist2` when
given two lists of unequal lengths.

+----------------------------------------------------------------------------+
| CHANGE TYPE:   Modified failure strings.		     		     |
|----------------------------------------------------------------------------|
| CHANGED BY:    RJB                                                         |
|----------------------------------------------------------------------------|
| FILES CHANGED: ml/hol-syn.ml						     |
|----------------------------------------------------------------------------|
| DATE:          17 October 1990.				             |
+----------------------------------------------------------------------------+

The ML functions list_mk_abs, list_mk_comb, list_mk_conj, list_mk_disj,
list_mk_imp, list_mk_forall and list_mk_exists now fail with the strings
`list_mk_abs`, `list_mk_comb`, `list_mk_conj`, `list_mk_disj`, `list_mk_imp`,
`list_mk_forall`, and `list_mk_exists` respectively.

+----------------------------------------------------------------------------+
| CHANGE TYPE:   new conversion: num_EQ_CONV.ml				     |
|----------------------------------------------------------------------------|
| CHANGED BY:    TFM                                                         |
|----------------------------------------------------------------------------|
| FILES CHANGED: ml/num.ml						     |
|----------------------------------------------------------------------------|
| DATE:          17 October 1990.					     |
+----------------------------------------------------------------------------+

A new conversion has been added for deciding equality of natural number
constants.  If n and m are terms constructed from numeral constants (i.e.
0,1,2,3.) and the successor function "SUC", then:

	num_EQ_CONV "n=m"

returns:

	|- (n=m) = T		if n and m represent the same number
	|- (n=m) = F		if n and m represent different numbers

In addition,

	num_EQ_CONV "tm:num = tm"

returns:

	|- (tm=tm) = T

A preliminary REFERENCE manual entry has been added.


+----------------------------------------------------------------------------+
| CHANGE TYPE:   explicit ML type constraints.				     |
|----------------------------------------------------------------------------|
| CHANGED BY:    TFM                                                         |
|----------------------------------------------------------------------------|
| FILES CHANGED: ml/conv.ml ml/tactics.ml ml/tacticals.ml		     |
|----------------------------------------------------------------------------|
| DATE:          17 October 1990.					     |
+----------------------------------------------------------------------------+

Explicit ML types have been added to the HOL sources such that the functions
listed below have the ML types also shown below:


  ALL_TAC : tactic 
  NO_TAC  : tactic

  FAIL_TAC: (string -> tactic)


  EVERY_ASSUM: (thm_tactic -> tactic)
  FIRST_ASSUM: (thm_tactic -> tactic) 
  POP_ASSUM:   (thm_tactic -> tactic) 

  ASSUM_LIST:     ((thm list -> tactic) -> tactic)
  POP_ASSUM_LIST: ((thm list -> tactic) -> tactic)

  EVERY: (tactic list -> tactic)
  FIRST: (tactic list -> tactic)

  THEN:    (tactic -> tactic -> tactic)
  ORELSE:  (tactic -> tactic -> tactic)

  THENL: (tactic -> tactic list -> tactic)

  CHANGED_CONV: (conv -> conv)



+----------------------------------------------------------------------------+
| CHANGE TYPE:   new ML functions last and butlast.			     |
|----------------------------------------------------------------------------|
| CHANGED BY:    RJB                                                         |
|----------------------------------------------------------------------------|
| FILES CHANGED: ml/lis.ml						     |
|----------------------------------------------------------------------------|
| DATE:          20 October 1990.					     |
+----------------------------------------------------------------------------+

Two new ML functions have been added for obtaining the last element of a
list and all but the last element of a list. These were originally defined
in the prog_logic88 library.

  last :    * list -> *
  butlast : * list -> * list

+----------------------------------------------------------------------------+
| CHANGE TYPE:   deletion of redundant definitions in prog_logic88 library.  |
|----------------------------------------------------------------------------|
| CHANGED BY:    RJB                                                         |
|----------------------------------------------------------------------------|
| FILES CHANGED: Library/prog_logic88/mk_dijkstra.ml			     |
|                Library/prog_logic88/syntax_functions.ml	 	     |
|----------------------------------------------------------------------------|
| DATE:          20 October 1990.					     |
+----------------------------------------------------------------------------+

The definition of last in Library/prog_logic88/mk_dijkstra.ml and the
definitions of last and butlast in Library/prog_logic88/syntax_functions.ml
have been commented-out since these functions are now available in the
basic HOL system.

+----------------------------------------------------------------------------+
| CHANGE TYPE:   deletion of rotate_left and rotate_right.                   |
|----------------------------------------------------------------------------|
| CHANGED BY:    RJB                                                         |
|----------------------------------------------------------------------------|
| FILES CHANGED: ml/lis.ml ml/goals.ml Library/taut/taut.ml	 	     |
|----------------------------------------------------------------------------|
| DATE:          20 October 1990.					     |
+----------------------------------------------------------------------------+

The functions rotate_left and rotate_right (defined in ml/lis.ml) have been
commented-out.

The calls to these functions in the definitions of rotate_goals
(in ml/goals.ml) and oprotate_goals (in Library/taut/taut.ml) have been
replaced by calls to hd, tl, @, last and butlast.

+----------------------------------------------------------------------------+
| CHANGE TYPE:   deletion of make_set / change to setify.                    |
|----------------------------------------------------------------------------|
| CHANGED BY:    RJB                                                         |
|----------------------------------------------------------------------------|
| FILES CHANGED: ml/genfns.ml ml/lis.ml				 	     |
|----------------------------------------------------------------------------|
| DATE:          20 October 1990.					     |
+----------------------------------------------------------------------------+

The functions setify (in ml/genfns.ml) and make_set (in ml/lis.ml) have the
same functionality but different definitions. The definition of make_set is
better, so the definition of setify in ml/genfns.ml has been commented-out,
and make_set has been renamed setify.

+----------------------------------------------------------------------------+
| CHANGE TYPE:   Hiding of local function (mapshape).	     		     |
|----------------------------------------------------------------------------|
| CHANGED BY:    TFM                                                         |
|----------------------------------------------------------------------------|
| FILES CHANGED: ml/tacticals.ml ml/ind.ml				     |
|----------------------------------------------------------------------------|
| DATE:          21 October 1990                                             |
+----------------------------------------------------------------------------+

The ML function mapshape has been made local to the places in which it is
used, and it is therefore no longer available at top-level.  The REFERENCE
entry for mapshape has been deleted.

+----------------------------------------------------------------------------+
| CHANGE TYPE:   new ML functions bndvar and body.	                     |
|----------------------------------------------------------------------------|
| CHANGED BY:    RJB                                                         |
|----------------------------------------------------------------------------|
| FILES CHANGED: ml/hol-syn.ml					 	     |
|----------------------------------------------------------------------------|
| DATE:          22 October 1990.					     |
+----------------------------------------------------------------------------+

Two new derived term destructor functions have been added. bndvar extracts
the bound variable from an abstraction. body obtains the body of an
abstraction. Both functions fail if the term they are given is not an
abstraction.

+----------------------------------------------------------------------------+
| CHANGE TYPE:   new ML functions list_mk_pair and strip_pair.               |
|----------------------------------------------------------------------------|
| CHANGED BY:    RJB                                                         |
|----------------------------------------------------------------------------|
| FILES CHANGED: ml/hol-syn.ml					 	     |
|----------------------------------------------------------------------------|
| DATE:          22 October 1990.					     |
+----------------------------------------------------------------------------+

Function list_mk_pair added. It constructs a term which is a tuple from a
list of component terms. strip_pair performs the inverse operation.

+----------------------------------------------------------------------------+
| CHANGE TYPE:   new conversion (let_CONV).	                     	     |
|----------------------------------------------------------------------------|
| CHANGED BY:    TFM							     |
|----------------------------------------------------------------------------|
| FILES CHANGED: ml/conv.ml					 	     |
|----------------------------------------------------------------------------|
| DATE:          22 October 1990.					     |
+----------------------------------------------------------------------------+

A conversion for reducing let-terms has been added to version 1.12.  
Given a term:                                    			
                                                                       
   "let v1 = x1 and ... and vn = xn in tm[v1,...,vn]"			
                                                                       
let_CONV proves that:							
                                                                       
   |- let v1 = x1 and ... and vn = xn in tm[v1,...,vn] 		
	=								
      tm[x1,...,xn/v1,...,vn]						
                                                                       
where t[t1,...,tn/x1,...,xn] is the result of "substituting" the 	
value xi for vi  in parallel in tm (see below).			
									
Note that the vi's can take any one of the following forms:  		
									
    Variables:    "x" etc.    						
    Tuples:       "(x,y)" "(a,b,c)" "((a,b),(c,d))" etc.		
    Applications: "f (x,y) z" "f x" etc.				
									
Variables are just substituted for. With tuples, the substitution is	
done component-wise, and function applications are effectively	
rewritten in the body of the let-term.				

EXAMPLES:

   #let_CONV "let x = 1 in x+y";;
   |- (let x = 1 in x + y) = 1 + y
   
   #let_CONV "let (x,y) = (1,2) in x+y";;
   |- (let (x,y) = 1,2 in x + y) = 1 + 2
   
   #let_CONV "let f x = 1 and f y = 2 in (f 10) + (f 20)";;
   |- (let f x = 1 and f y = 2 in (f 10) + (f 20)) = 2 + 2
   
   #let_CONV "let f x = x + 1 and g x = x + 2 in f(g(f(g 0)))";;
   |- (let f x = x + 1 and g x = x + 2 in f(g(f(g 0)))) =
      (((0 + 2) + 1) + 2) + 1
   
   #let_CONV "let f x y = x+y in f 1";; 	 % NB: partial application %
   |- (let f x y = x + y in f 1) = (\y. 1 + y)     
   

A preliminary REFERENCE manual entry exists.

+----------------------------------------------------------------------------+
| CHANGE TYPE:   new ML functions mk_cons, dest_cons, is_cons.               |
|----------------------------------------------------------------------------|
| CHANGED BY:    RJB                                                         |
|----------------------------------------------------------------------------|
| FILES CHANGED: ml/hol-syn.ml					 	     |
|----------------------------------------------------------------------------|
| DATE:          24 October 1990.					     |
+----------------------------------------------------------------------------+

Functions have been added for constructing, destructing and discriminating
terms which are list constructions (Lisp's CONS). mk_cons forms a term
representing a list from terms for the head and tail of the list.

+----------------------------------------------------------------------------+
| CHANGE TYPE:   new ML functions mk_list, dest_list, is_list.               |
|----------------------------------------------------------------------------|
| CHANGED BY:    RJB                                                         |
|----------------------------------------------------------------------------|
| FILES CHANGED: ml/hol-syn.ml					 	     |
|----------------------------------------------------------------------------|
| DATE:          24 October 1990.					     |
+----------------------------------------------------------------------------+

Functions have been added for constructing, destructing and discriminating
entire lists. mk_list constructs a term representing a list from a list of
terms for the elements of the list. It also requires the type of the
elements to be given so that if the list of terms is empty, it can construct
a null list of the correct type.

+----------------------------------------------------------------------------+
| CHANGE TYPE:   revised conversion: ADD_CONV.				     |
|----------------------------------------------------------------------------|
| CHANGED BY:    TFM                                                         |
|----------------------------------------------------------------------------|
| FILES CHANGED: ml/num.ml						     |
|----------------------------------------------------------------------------|
| DATE:          23 October 1990					     |
+----------------------------------------------------------------------------+

The conversion ADD_CONV (see above) has been replaced by a new, iterative,
version, which can add numbers of arbitrary size without running out of stack.


+----------------------------------------------------------------------------+
| CHANGE TYPE:   revised library: string.				     |
|----------------------------------------------------------------------------|
| CHANGED BY:    TFM                                                         |
|----------------------------------------------------------------------------|
| FILES CHANGED: Library/string						     |
|----------------------------------------------------------------------------|
| DATE:          27 October 1990					     |
+----------------------------------------------------------------------------+

The string library has been revised.  Users should notice no difference, 
except that the functions defined in the library go a little bit faster.

+----------------------------------------------------------------------------+
| CHANGE TYPE:   Renaming (constructors for preterms)			     |
|----------------------------------------------------------------------------|
| CHANGED BY:    TFM	                                                     |
|----------------------------------------------------------------------------|
| FILES CHANGED: lisp/f-typeol.l       	                                     |
|                ml/hol-syn.ml         					     |
|----------------------------------------------------------------------------|
| DATE:          4 November 1990					     |
+----------------------------------------------------------------------------+

The definition of preterms in HOL (see above) has been changed from:

rectype preterm = var      of string                       % Variables       %
                | const    of string                       % Constants       %
                | comb     of preterm # preterm            % Combinations    %
                | abs      of preterm # preterm            % Abstractions    %
                | typed    of preterm # type               % Explicit typing %
                | antiquot of term;;                       % Antiquotation   %

to:

rectype preterm = 
    preterm_var      of string                       % Variables       %
  | preterm_const    of string                       % Constants       %
  | preterm_comb     of preterm # preterm            % Combinations    %
  | preterm_abs      of preterm # preterm            % Abstractions    %
  | preterm_typed    of preterm # type               % Explicit typing %
  | preterm_antiquot of term;;                       % Antiquotation   %

That is, the constructors have been renamed.

+----------------------------------------------------------------------------+
| CHANGE TYPE:   New conversion.				    	     |
|----------------------------------------------------------------------------|
| CHANGED BY:    TFM							     |
|----------------------------------------------------------------------------|
| FILES CHANGED: ml/num.ml						     |
|----------------------------------------------------------------------------|
| DATE:          6 November 1990.					     |
+----------------------------------------------------------------------------+

A new conversion, EXISTS_LEAST_CONV, has been added to the system. 

EXISTS_LEAST_CONV applies the well-ordering property to non-empty sets of
numbers specified by predicates.  A call to 

   EXISTS_LEAST_CONV "?n:num. P[n]"

returns: 

   |- (?n. P[n]) = ?n. P[n] /\ !n'. (n' < n) ==> ~P[n']	

A preliminary REFERENCE entry has been added.

+----------------------------------------------------------------------------+
| CHANGE TYPE:   Modified conversion.				    	     |
|----------------------------------------------------------------------------|
| CHANGED BY:    TFM							     |
|----------------------------------------------------------------------------|
| FILES CHANGED: ml/conv.ml						     |
|----------------------------------------------------------------------------|
| DATE:          8 November 1990.					     |
+----------------------------------------------------------------------------+

The built-in conversion EXISTS_IMP_FORALL_CONV has been reimplemented, and
renamed to be called LEFT_IMP_EXISTS_CONV.  The conversion implements the
following theorem-scheme: 

     |- (?x. t1[x]) ==> t2  =  !x'. t1[x'] ==> t2 

where x' is a variant of x chosen not to be free in (?x.t[x])==>t2. A
preliminary REFERENCE manual entry exists.

+----------------------------------------------------------------------------+
| CHANGE TYPE:   New conversions.				    	     |
|----------------------------------------------------------------------------|
| CHANGED BY:    TFM							     |
|----------------------------------------------------------------------------|
| FILES CHANGED: ml/conv.ml						     |
|----------------------------------------------------------------------------|
| DATE:          8 November 1990.					     |
+----------------------------------------------------------------------------+

The following two new conversions are now built-in:

FORALL_AND_CONV : moves universal quantifiers into conjunction:
									
   |- (!x. P /\ Q) = (!x.P) /\ (!x.Q)					

AND_FORALL_CONV : moves universal quantifiers out of conjunction.	
									
   |- (!x.P) /\ (!x.Q) = (!x. P /\ Q) 					

Preliminary REFERENCE manual entries have been created.


+----------------------------------------------------------------------------+
| CHANGE TYPE:   New conversion (X_SKOLEM_CONV, SKOLEM_CONV).		     |
|----------------------------------------------------------------------------|
| CHANGED BY:    TFM							     |
|----------------------------------------------------------------------------|
| FILES CHANGED: ml/conv.ml						     |
|----------------------------------------------------------------------------|
| DATE:          9 November 1990.					     |
+----------------------------------------------------------------------------+

Two new conversions have been added for introducing skolem functions.  The
conversion X_SKOLEM_CONV takes a variable parameter, "f" say, and proves:

   |- (!x1...xn. ?y. tm[x1,...,xn,y])
        = 
      (?f. !x1...xn. tm[x1,..,xn,f x1 ... xn]

for any input term "!x1...xn. ?y. tm[x1,...,xn,y]".  Note that when n=0, this
is equivalent to alpha-conversion:

  |- (?y.tm[y]) = (?f.tm[f])

and that the conversion fails if there is already a free variable "f" of
the appropriate type in the input term. Eg:

  X_SKOLEM_CONV "f:num->*" "!n:num. ?x:*. x = (f n)";;

will fail.  The conversion SKOLEM_CONV is like X_SKOLEM_CONV, except that it
uses a primed variant of the name of the existentially quantified variable
as the name of the skolem function it introduces.  For example:

  SKOLEM_CONV "!x. ?y. P x y"

proves that:

  |- ?y. !x. P x (y x)

Preliminary REFERENCE manual entries exist.

+----------------------------------------------------------------------------+
| CHANGE TYPE:   Renaming (MOVE_EXISTS_OUT_CONV)			     |
|----------------------------------------------------------------------------|
| CHANGED BY:    TFM							     |
|----------------------------------------------------------------------------|
| FILES CHANGED: ml/conv.ml						     |
|----------------------------------------------------------------------------|
| DATE:          10 November 1990.					     |
+----------------------------------------------------------------------------+

The built-in conversion MOVE_EXISTS_OUT_CONV is replaced by a new
implementation called RIGHT_AND_EXISTS_CONV. (See also next entry below).


+----------------------------------------------------------------------------+
| CHANGE TYPE:   New conversions.					     |
|----------------------------------------------------------------------------|
| CHANGED BY:    TFM							     |
|----------------------------------------------------------------------------|
| FILES CHANGED: ml/conv.ml						     |
|----------------------------------------------------------------------------|
| DATE:          11 November 1990.					     |
+----------------------------------------------------------------------------+

A complete and systematically-named set of conversions for moving quantifiers
inwards and outwards through the logical connectives ~, /\, \/, and ==> has
been added to the system.  The naming scheme is based on the following
atoms:

   <quant> := FORALL | EXISTS
   <conn>  := NOT | AND | OR | IMP
   [dir]   := LEFT | RIGHT			(optional)

1: the conversions for moving quantifiers inwards are called:
        
   <quant>_<conn>_CONV

where the quantifier <quant> is to be moved inwards through <conn>.

2: the conversions for moving quantifiers outwards are called:
   
   [dir]_<conn>_<quant>_CONV
      
where <quant> is to be moved outwards through <conn>, and the optional
[dir] identifies which operand (left or right) contains the quantifier.

The complete set is:

   NOT_FORALL_CONV    |- ~(!x.P) = ?x.~P
   NOT_EXISTS_CONV    |- ~(?x.P) = !x.~P
   EXISTS_NOT_CONV    |- (?x.~P) = ~!x.P
   FORALL_NOT_CONV    |- (!x.~P) = ~?x.P

   FORALL_AND_CONV         |- (!x. P /\ Q) = (!x.P) /\ (!x.Q)
   AND_FORALL_CONV         |- (!x.P) /\ (!x.Q) = (!x. P /\ Q)
   LEFT_AND_FORALL_CONV    |- (!x.P) /\ Q = (!x'. P[x'/x] /\ Q)
   RIGHT_AND_FORALL_CONV   |- P /\ (!x.Q) = (!x'. P /\ Q[x'/x])

   EXISTS_OR_CONV          |- (?x. P \/ Q) = (?x.P) \/ (?x.Q)
   OR_EXISTS_CONV          |- (?x.P) \/ (?x.Q) = (?x. P \/ Q)
   LEFT_OR_EXISTS_CONV     |- (?x.P) \/ Q = (?x'. P[x'/x] \/ Q)
   RIGHT_OR_EXISTS_CONV    |- P \/ (?x.Q) = (?x'. P \/ Q[x'/x])

   FORALL_OR_CONV 
     |- (!x.P \/ Q) = P \/ !x.Q	         [x not free in P]
     |- (!x.P \/ Q) = (!x.P) \/ Q	 [x not free in Q]
     |- (!x.P \/ Q) = (!x.P) \/ (!x.Q)   [x not free in P or Q]

   OR_FORALL_CONV	  
     |- (!x.P) \/ (!x.Q) = (!x.P \/ Q)   [x not free in P or Q]

   LEFT_OR_FORALL_CONV    |- (!x.P) \/ Q = !x'. P[x'/x] \/ Q
   RIGHT_OR_FORALL_CONV   |- P \/ (!x.Q)  = !x'. P \/ Q[x'/x]

   EXISTS_AND_CONV 
     |- (?x.P /\ Q) = P /\ ?x.Q	         [x not free in P]
     |- (?x.P /\ Q) = (?x.P) /\ Q	 [x not free in Q]
     |- (?x.P /\ Q) = (?x.P) /\ (?x.Q)   [x not free in P or Q]

   AND_EXISTS_CONV	  
     |- (?x.P) /\ (?x.Q) = (?x.P /\ Q)   [x not free in P or Q]

   LEFT_AND_EXISTS_CONV    |- (?x.P) /\ Q = ?x'. P[x'/x] /\ Q
   RIGHT_AND_EXISTS_CONV   |- P /\ (?x.Q)  = ?x'. P /\ Q[x'/x]

   FORALL_IMP_CONV	   
     |- (!x.P ==> Q) = P ==> !x.Q	   [x not free in P]
     |- (!x.P ==> Q) = (?x.P) ==> Q	   [x not free in Q]
     |- (!x.P ==> Q) = (?x.P) ==> (!x.Q)   [x not free in P or Q]

   LEFT_IMP_FORALL_CONV   |- (!x.P) ==> Q = !x'. P[x/'x] ==> Q
   RIGHT_IMP_FORALL_CONV  |- P ==> (!x.Q) = !x'. P ==> Q[x'/x]

   EXISTS_IMP_CONV	   
     |- (?x.P ==> Q) = P ==> ?x.Q	   [x not free in P]
     |- (?x.P ==> Q) = (!x.P) ==> Q	   [x not free in Q]
     |- (?x.P ==> Q) = (!x.P) ==> (?x.Q)   [x not free in P or Q]

   LEFT_IMP_EXISTS_CONV   |- (?x.P) ==> Q = !x'. P[x/'x] ==> Q
   RIGHT_IMP_EXISTS_CONV  |- P ==> (?x.Q) = ?x'. P ==> Q[x'/x]

REFERENCE manual entries exist for all these functions.

+----------------------------------------------------------------------------+
| CHANGE TYPE:   Bugfix:      						     |
|----------------------------------------------------------------------------|
| CHANGED BY:    MJCG                                                        |
|----------------------------------------------------------------------------|
| FILES CHANGED: lisp/f-tran.l     					     |
|                lisp/f-lis.l                                                |
|----------------------------------------------------------------------------|
| DATE:          10 November 1990		                             |
+----------------------------------------------------------------------------+

TFM discovered the following bug:

   #let ap,x = 1,2;;
   ap = 1 : int
   Internal bad memory reference, you are advised to (reset).  

This has been fixed by renaming the lisp function ap defined in f-tran.l
to be ap.  (Additional "ap"s changed to %ap in f-lis.l TFM).

+----------------------------------------------------------------------------+
| CHANGE TYPE:   Change to help system					     |
|----------------------------------------------------------------------------|
| CHANGED BY:    MJCG                                                        |
|----------------------------------------------------------------------------|
| FILES CHANGED: lisp/f-system.l     					     |
|		 lisp/f-help.l						     |
|		 lisp/f-dml.l						     |
|----------------------------------------------------------------------------|
| DATE:          12 November 1990		                             |
+----------------------------------------------------------------------------+

The helps system now uses "cat" rather than "more" as the default for
displaying help files. This default can be changed with the ML function:

   set_help : string -> string

This installs a new user-supplied help function, and returns the
previous one as result. The effect of

   help `FOO`;;

is to pipe the appropriate help file into the current help function,
with the top level of ML being the standard output.

For example,

   set_help `lpr`;;

will cause the help file to be printed instead of being displayed and

   set_help `lpr -Pelm`;;

will cause it to be printed to the printer elm (at Cambridge).


+----------------------------------------------------------------------------+
| CHANGE TYPE:   bug fix (flags in Common Lisp).			     |
|----------------------------------------------------------------------------|
| CHANGED BY:    MJCG                                                        |
|----------------------------------------------------------------------------|
| FILES CHANGED: lisp/f-iox-stand.l					     |
|----------------------------------------------------------------------------|
| DATE:          23 November 1990.					     |
+----------------------------------------------------------------------------+

Lisp function cdddddr expanded out since it is not defined in Common Lisp.

+----------------------------------------------------------------------------+
| CHANGE TYPE:   bug fix (variable priming by inst).			     |
|----------------------------------------------------------------------------|
| CHANGED BY:    MJCG/TFM                                                    |
|----------------------------------------------------------------------------|
| FILES CHANGED: lisp/f-inst.l						     |
|----------------------------------------------------------------------------|
| DATE:          25 November 1990.					     |
+----------------------------------------------------------------------------+

The problem was that inst sometimes did too much renaming of variables.  In
particular, inst primed instantiated variables whose names happen to be also
the names of constants.  For example:

   inst [] [":num",":*"] (mk_var(`o`,":*"))

returned the variable "o':num" instead of "o:num" because `o` is already
the name of a constant.  

Now, this is not a problem most of the time.  But, when one wants to use
match, INST_TYPE and INST to get an instance of a theorem there may be a
problem. For example:

   let th = REFL (mk_var(`o`,":*"));;

and then

   let insttm,instty = match (concl th) "1=1";; 

This gives the variable substitution and type instantiation:

   insttm = [("1", "o:num")]
   instty = [(":num", ":*")] 

But when one tries to apply these to the theorem |- o:* = o by doing

   INST insttm (INST_TYPE instty th)

then because INST_TYPE uses inst we get |- o' = o' rather than 
the expected |- 1 = 1.

The code for inst has been modified so that it no longer adds these gratuitous
primes to the names of variables. 


+----------------------------------------------------------------------------+
| CHANGE TYPE:   new ML function getenv					     |
|----------------------------------------------------------------------------|
| CHANGED BY:    JVT							     |
|----------------------------------------------------------------------------|
| FILES CHANGED: lisp/f-dml.l lisp/f-system.l				     |
|----------------------------------------------------------------------------|
| DATE:          26 November 1990.                                           |
+----------------------------------------------------------------------------+

It was necessary to determine the value of the DISPLAY environment variable in
order to tie the help system to a prototype X Windows display tool.  It was
thought that being able to get environment variable values was a good thing
in general, and the function was therefore added to the system.

+----------------------------------------------------------------------------+
| CHANGE TYPE:   Deletion of assumption-dependent specification feature.     |
|----------------------------------------------------------------------------|
| CHANGED BY:    TFM							     |
|----------------------------------------------------------------------------|
| FILES CHANGED: ml/hol-thyfn.ml theories/mk_bool.ml manual.		     |
|----------------------------------------------------------------------------|
| DATE:          1 December 1990.					     |
+----------------------------------------------------------------------------+

In version 11, there was a somewhat ad-hoc feature of new_specification which
allowed one to make constant specifications that depend on assumptions (see
section 11.6.2.2 of DESCRIPTION).  This feature has now been deleted.

A more elegant mechanism to support assumption-dependent constant
specifications should be added to a future version of Hol.

+----------------------------------------------------------------------------+
| CHANGE TYPE:   Deletions (various)					     |
|----------------------------------------------------------------------------|
| CHANGED BY:    TFM							     |
|----------------------------------------------------------------------------|
| FILES CHANGED: ml/drul.ml lisp/f-thyfn.l ml/hol-thyfn.ml		     |
|----------------------------------------------------------------------------|
| DATE:          1 December 1990.					     |
+----------------------------------------------------------------------------+

As a cconsequence of the work done for the change descibed in the previous
entry, the following built-in ML functions are no longer required and have
therefore been deleted:

   CLOSE_UP 
   save_open_thm
   pp_theorem
   pp_delete_theorem
   pp_theorems

The REFERENCE manual has been updated accordingly.

+----------------------------------------------------------------------------+
| CHANGE TYPE:   Modified failure strings.		     		     |
|----------------------------------------------------------------------------|
| CHANGED BY:    TFM                                                         |
|----------------------------------------------------------------------------|
| FILES CHANGED: ml/lis.ml						     |
|----------------------------------------------------------------------------|
| DATE:          1 December 1990					     |
+----------------------------------------------------------------------------+

The following functions now fail with the strings shown below:

	assoc       --> fails with `assoc`
	rev_assoc   --> fails with `rev_assoc`

The REFERENCE manual has been updated accordingly.

+----------------------------------------------------------------------------+
| CHANGE TYPE:   Directory reorganization.				     |
|----------------------------------------------------------------------------|
| CHANGED BY:    TFM                                                         |
|----------------------------------------------------------------------------|
| FILES CHANGED: help Manual.						     |
|----------------------------------------------------------------------------|
| DATE:          1 December 1990					     |
+----------------------------------------------------------------------------+

The help files and manual have been split apart into two separate directories.
The top-level of the HOL distribution directory now contains:

   Manual  :  directory containing the manual sources.
  
   help    :  directory containing text files for online help, as well
   	      as for the REFERENCE part of the manual.

+----------------------------------------------------------------------------+
| CHANGE TYPE:   Revised search path mechanism.		     		     |
|----------------------------------------------------------------------------|
| CHANGED BY:    TFM                                                         |
|----------------------------------------------------------------------------|
| FILES CHANGED: Makefile, ml/gen.ml					     |
|----------------------------------------------------------------------------|
| DATE:          1 December 1990					     |
+----------------------------------------------------------------------------+

The search path mechanism has been revised in the following ways:

  1) Library pathnames are now no longer on the default search path.  Nor
     are they added to the search path when a library is loaded (it is
     the resposiblity of the library's load-file to do this, if desired).
     As a consequence, the built-in value Libraries is no longer used.

  2) The initial search path is now:

        [``; `~/`; `<directory>/theories/`]

     where <directory> is the site-specific absolute pathname in which
     the hol distribution directory (`hol') resides. 
   
  3) The ML functions add_to_search_path and append_to_search_path are
     no longer built-in.  Users may define them, if required, by:

        let add_to_search_path p = set_search_path(p.search_path());;
        let append_to_search_path p = set_search_path(search_path()@[p]);;

  4) The install function now sets the search path to:

        [``; `~/`; <arg> ^ `/theories/`]

     where <arg> is the string argument to install.

+----------------------------------------------------------------------------+
| CHANGE TYPE:   new ML function (library_pathname).			     |
|----------------------------------------------------------------------------|
| CHANGED BY:    TFM                                                         |
|----------------------------------------------------------------------------|
| FILES CHANGED: lisp/f-tml.l					             |
|----------------------------------------------------------------------------|
| DATE:          1 December 1990					     |
+----------------------------------------------------------------------------+

The function library_pathname returns the internal pathname used by HOL to
load libraries.  This pathname, which is site-specific and is given an initial
value when the system is built, should be the absolute pathname of the HOL 
system library directory.  This pathname will typically have the form:

   `<directory>/hol/Library`

where <directory> is the site-specific absolute pathname in which the hol
distribution directory (`hol') resides. The value returned by library_pathname
can be changed by users only via the install function.  

The string returned by library_pathname is primarily used in library
load-files to update the HOL search path and help search path.  For example,
suppose that in a library lib there is a directory help which contains online
help files specific to this library.  The load file lib.ml can then update the
help search path as follows:

   let path = library_pathname() ^ `/lib/help/` in
       set_help_search_path (path . help_search_path());;

This will make the help files of the library lib available for online help
whenever the library is loaded. (see below for hew_search_path).

+----------------------------------------------------------------------------+
| CHANGE TYPE:   Deletion: HOLdir					     |
|----------------------------------------------------------------------------|
| CHANGED BY:    TFM                                                         |
|----------------------------------------------------------------------------|
| FILES CHANGED: ml/gen.ml						     |
|----------------------------------------------------------------------------|
| DATE:          1 December 1990					     |
+----------------------------------------------------------------------------+

The new function library_pathname has made the asignable variable HOLdir
unnecessary.  HOLdir has therefore been deleted. 

+----------------------------------------------------------------------------+
| CHANGE TYPE:   Deletion:  set_hol_lib_dir				     |
|----------------------------------------------------------------------------|
| CHANGED BY:    TFM                                                         |
|----------------------------------------------------------------------------|
| FILES CHANGED: lisp/f-tml.l						     |
|----------------------------------------------------------------------------|
| DATE:          1 December 1990					     |
+----------------------------------------------------------------------------+

The ML function set_hol_lib_dir was required in previous versions of HOL only
fot internal purposes, and it has now been deleted.

+----------------------------------------------------------------------------+
| CHANGE TYPE:   Deletions: loading from libraries.			     |
|----------------------------------------------------------------------------|
| CHANGED BY:    TFM                                                         |
|----------------------------------------------------------------------------|
| FILES CHANGED: ml/gen.ml						     |
|----------------------------------------------------------------------------|
| DATE:          1 December 1990					     |
+----------------------------------------------------------------------------+

The ML functions:

  load_from_lib
  loadt_from_lib
  loadf_from_lib
  loadx

are no longer available as built-in functions.  Users may easily define them,
if required, by:

  let load_from_lib t lib file = 
      load((library_pathname() ^ `/` ^ lib ^ `/` ^ file), t);;

  let loadt_from_lib = load_from_lib true
  and loadf_from_lib = load_from_lib false;;

  let loadx tok = load(tok, get_flag_value `print_lib`);;

The REFERENCE manual has been updated.

+----------------------------------------------------------------------------+
| CHANGE TYPE:   New functions: help search path.			     |
|----------------------------------------------------------------------------|
| CHANGED BY:    TFM                                                         |
|----------------------------------------------------------------------------|
| FILES CHANGED: lisp/f-help.l					  	     |
|----------------------------------------------------------------------------|
| DATE:          1 December 1990					     |
+----------------------------------------------------------------------------+

Two new functions:

  set_help_search_path
  help_search_path

have been added to the system for accessing the internal search path used by
HOL to find online help files.  The help search path has precisely the same
format as the regular search path, and these two function are analogous to
the ML functions search_path and set_search_path.

+----------------------------------------------------------------------------+
| CHANGE TYPE:   Revised function: install.				     |
|----------------------------------------------------------------------------|
| CHANGED BY:    TFM                                                         |
|----------------------------------------------------------------------------|
| FILES CHANGED: ml/gen.ml						     |
|----------------------------------------------------------------------------|
| DATE:          1 December 1990					     |
+----------------------------------------------------------------------------+

The install function has been revised to deal properly with the location of
online help files.


+----------------------------------------------------------------------------+
| CHANGE TYPE:   New function: ancestors.				     |
|----------------------------------------------------------------------------|
| CHANGED BY:    TFM                                                         |
|----------------------------------------------------------------------------|
| FILES CHANGED: ml/hol-thyfn.ml					     |
|----------------------------------------------------------------------------|
| DATE:          9 December 1990					     |
+----------------------------------------------------------------------------+

A call to 

  ancestors `th`;;

returns a list of all the proper ancestors (i.e.  parents, parents of parents,
etc.) of the theory `th`. Fails if `th` is not an ancestor of the current
theory.  A new REFERENCE manual entry to this effect exists.


+----------------------------------------------------------------------------+
| CHANGE TYPE:   Support for new interface experiments.			     |
|----------------------------------------------------------------------------|
| CHANGED BY:    MJCG                                                        |
|----------------------------------------------------------------------------|
| FILES CHANGED: lisp/f-tml.l						     |
|                lisp/f-parser.l					     |
|                lisp/hol-pars.l					     |
|                lisp/hol-writ.l					     |
|----------------------------------------------------------------------------|
| DATE:          11 December 1990					     |
+----------------------------------------------------------------------------+

Some flags have been set up to enable HOL to interact by sending and
receiving S-expressions from Centaur (an interface tool developed at Inria).
Normal users should not use these flags as they are experimental and
subject to extensive change.

If the flag `print_parse_trees` is set to true then ML prints out the
parse tree of the expression or declaration just input. Note that this
is usually the value in %pt, but not always, because in some cases the
read-eval-print loop of ML destructively modifies %pt. A variable %pt1
holds the parse tree that is printed; this variable is only maintained
(by okpass in f-tml.l) if the flag `print_parse_trees` is true.

If the flag `print_sexpr` is set to true, then an S-expression
representing the value of a term or theorem is printed instead of the
normal output.  The printing of types is suppressed for all values.

The printing in the two cases above is pretty if the flag `pp_sexpr`
is true (the default) and non-pretty otherwise.

If the flag `read_sexpr` is set to true, then parse trees may be input
directly between begin_parse_tree and end_parse_tree. For example:

   begin_parse_tree
    (mk-let ((mk-var x) mk-quot (MK=CONST T)))
   end_parse_tree;;

is equivalent to:

   let x = "T";;

Here is an example session:

   #let x = 1;;
   x = 1 : int

   #set_flag(`print_parse_trees`,true);;
   false : bool

   (mk-empty)

   #let x = 1;;
   x = 1 : int

   (mk-let ((mk-var x) mk-intconst 1))

   #set_flag(`read_sexpr`, true);;
   true : bool

   (mk-appn (mk-var set_flag) (mk-dupl (mk-tokconst read_sexpr) (mk-boolconst t)))

   #begin_parse_tree (mk-let ((mk-var x) mk-intconst 1)) end_parse_tree;;
   x = 1 : int

   (mk-let ((mk-var x) mk-intconst 1))

   #set_flag(`print_parse_trees`,false);;
   true : bool

   #begin_parse_tree
   # (mk-let ((mk-var x) mk-quot (MK=CONST T)))
   #end_parse_tree;;
   x = "T" : term

   #

Terms can also be input in the form printed out when `print_sexpr` is
true, by enclosing them between begin_term and end_term. For example:

   begin_term
   (comb (comb (const + (fun (num) (fun (num) (num))))
               (var x (num))
               (fun (num) (num)))
         (const |1| (num))
         (num)) 
   end_term;;

is equivalent to:

   "x+1";;

Continuing our session:

   #begin_term
   #  (comb (comb (const + (fun (num) (fun (num) (num))))
   #             (var x (num))
   #              (fun (num) (num)))
   #        (const |1| (num))
   #        (num)) 
   #  end_term;;
   "x + 1" : term

   #set_flag(`print_sexpr`, true);;
   false 

   #"x+1";;
   (comb (comb (const + (fun (num) (fun (num) (num))))
               (var x (num))
               (fun (num) (num)))
         (const |1| (num))
         (num)) 
  
   #[1;2;3];;
   [1; 2; 3] 

   #

+----------------------------------------------------------------------------+
| CHANGE TYPE:   Renaming						     |
|----------------------------------------------------------------------------|
| CHANGED BY:    TFM                                                         |
|----------------------------------------------------------------------------|
| FILES CHANGED: ml/abs-rep.ml ml/tydefs.ml				     |
|----------------------------------------------------------------------------|
| DATE:          9 December 1990					     |
+----------------------------------------------------------------------------+

The ML function define_new_type_isomorphisms has been renamed:

   define_new_type_bijections

+----------------------------------------------------------------------------+
| CHANGE TYPE:   New inference rule: EXISTENCE				     |
|----------------------------------------------------------------------------|
| CHANGED BY:    TFM                                                         |
|----------------------------------------------------------------------------|
| FILES CHANGED: ml/drul.ml						     |
|----------------------------------------------------------------------------|
| DATE:          11 December 1990					     |
+----------------------------------------------------------------------------+

A new inference rule:

              A |- ?!x. P[x]
  EXISTENCE ------------------
              A |- ?x. P[x]

is now provided for fast derivation of existence from unique existence.

A preliminary REFERENCE manual entry exists.

+----------------------------------------------------------------------------+
| CHANGE TYPE:   New library: trs					     |
|----------------------------------------------------------------------------|
| CHANGED BY:    RJB                                                         |
|----------------------------------------------------------------------------|
| FILES CHANGED: Library/trs						     |
|----------------------------------------------------------------------------|
| DATE:          18 January 1991					     |
+----------------------------------------------------------------------------+

A new library has been added: A Theorem Retrieval System.

This library does not contain any theories. It is a tool for finding stored
theorems by specifying a template for the term structure of the theorem.

+----------------------------------------------------------------------------+
| CHANGE TYPE:   Improvement in `resolution' tactics. (RES_CANON)	     |
|----------------------------------------------------------------------------|
| CHANGED BY:    TFM                                                         |
|----------------------------------------------------------------------------|
| FILES CHANGED: ml/resolve.ml						     |
|----------------------------------------------------------------------------|
| DATE:          17 January 1991					     |
+----------------------------------------------------------------------------+

As part of a total reimplementation of the HOL "resolution" tools,
the built-in function RES_CANON has been rewritten. RES_CANON applies
certain transformations to the implicative theorems used by

   IMP_RES_THEN, RES_THEN, IMP_RES_TAC and RES_TAC

to draw consequences by modus ponens from the assumptions of a goal.

In version 1.12, these transformations have been rationalized, and 
complete list of transformations is now given by repeatedly applying:

   ~t              --->        t ==> F        (at outermost level)	
   t1 /\ t2	   --->	       t1, t2					
   (t1/\t2)==>t    --->	       t1==>(t2==>t), t2==>(t1==>t)		
   (t1\/t2)==>t    --->	       t1==>t, t2==>t				
   t1 = t2         --->        t1==>t2, t2==>t1			
   !x. t1 ==> t2   --->        t1 ==> !x.t2   (x not free in t1)	 
   (?x.t1) ==> t2  --->	       !x'. t1[x'/x] ==> t2			

There are several consequences of this revision.  The consequences of
the addition of the transformation:

   !x. t1 ==> t2   --->        t1 ==> !x.t2   (x not free in t1)

are explained above in the entry for 24 April 1990.  

In previous versions, the second transformation listed above was simply:

   (t1/\t2)==>t    --->	       t1==>(t2==>t)

But t2==>(t1==>t) is now also added to the list of implications
returned by RES_CANON.  This allows more resolvents to be found than
was previously possible.  In particular, given a goal with assumption 
Q but NOT assumption P:

  <goal>
   [Q]

and the theorem:

  th |- (P /\ Q) ==> R

using previous version of IMP_RES_TAC with this theorem would have no effect
on the goal.  In the new version, we get the new subgoal:

  <goal>
   [Q]
   [P ==> R]

with the additional assumption "P ==> R".  This works because the theorem
th is transformed into the list of theorems:

   [|- P ==> (Q ==> R) ; |- Q ==> (P ==> R)]

from which it can be deduced by MP from the assumption Q that P==>R.

The third major change is the addition of the transformation:

   (?x.t1) ==> t2  --->	       !x'. t1[x'/x] ==> t2

where x' is not free in t2.  The idea behind this is the following.
The standard situation is for the assumptions of a goal to be in
what I will call "fully stripped" form.  (This is the kind of situation
which comes from using the very common tactics STRIP_TAC, STRIP_ASSUME_TAC,
and so on.)  In particular, it is to be expected that the assumptions
of a goal will usually NOT be existentially quantified (at the outermost
level).  Instead, any existentially-quantified terms will be stripped of
these quantifiers (by the introduction of appropriate variables standing 
for the witness) when they are added to the assumption list.  For example,
STRIP_TAC applied to the goal 

   (?x. P x) ==> Q

gives:

   Q
   [P x']		(where x' not free in Q)

rather than:

   Q
   [?x. P x]		(which is what DISCH_TAC would give).

Now, since existential quantifiers are expected in the normal situation
to be stripped from all assumptions, it is reasonable to transform
implications of the form:

  |- (?x. t1) ==> t2    into     |- !x'. t1[x'/x] ==> t2    

before doing resolution.

The new RES_CANON now uses the ~t --> t==>F on all top-level conjuncts.
For example:

  |- ~P /\ (Q==>R)

now (correctly) gives:

  [|- P ==> F; |- Q ==> R]

instead of the old list:

  [|- ~P; |- Q ==> R]

The final modification to RES_CANON is to change the transformation:

   t1 = t2         --->        t1==>t2, t2==>t1, t1=t2

for top-level equations into 

   t1 = t2         --->        t1==>t2, t2==>t1

since an equation t1=t2 on its own can never be used with MP to 
generate resolvents.  As a result, the new version of RES_CANON
generates from the theorem

  |- P = Q

the list:

  [|- P ==> Q ; |- Q ==> P]

where the old version would also have the useless |- P = Q in the list.
Note that the new version still gives:

  [|- R ==> (P = Q); |- R ==> P ==> Q; |- R ==> Q ==> P]

for the theorem:
   
  |- R ==> (P = Q)

Finally, the function RES_CANON now fails (with an appropriate message)
if no implications can be derived from the input theorem.

See also contrib/resolve.

+----------------------------------------------------------------------------+
| CHANGE TYPE:   Improvement in `resolution' tactics (IMP_RES_THEN, RES_THEN)|
|----------------------------------------------------------------------------|
| CHANGED BY:    TFM                                                         |
|----------------------------------------------------------------------------|
| FILES CHANGED: ml/resolve.ml						     |
|----------------------------------------------------------------------------|
| DATE:          17 January 1991					     |
+----------------------------------------------------------------------------+

The resolution primitive IMP_RES_THEN has been considerably modified in
HOL version 1.12.  In previous versions, the tactic:

   IMP_RES_THEN ttac |- P1 ==> P2 ==> P3 ==> ... Pn ==> Q

when applied to a goal of the form:

   <goal>
   [P1]
   [P2]
   [P3]
    .
    .
    .
   [Pn]
    
would generate a series of intermediate `resolvents':

  r1)    |- P2 ==> P3 ==> ... Pn ==> Q
  r2)    |- P3 ==> ... Pn ==> Q
  rn-1)  |- Pn ==> Q
  rn)    |- Q

and then, in effect, apply the tactic:

  (ttac r1) THEN (ttac r2) THEN ... THEN (ttac rn-1) THEN (ttac rn)

to the goal.

The new version of IMP_RES_THEN does not have this built-in iteration.
Instead, it is designed to be repeated explicitly, and does only a single
step of in this resolution process.  That is, the new version will
in the case shown above generate only the single resolvent:

  r1)    |- P2 ==> P3 ==> ... Pn ==> Q

and then apply the tactic (ttac r1) to the goal.

To repeatedly generate resolvents, the new function REPEAT_GTCL can be used
in conjunction with IMP_RES_THEN (see below).

FAILURE. A call to:

   IMP_RES_THEN ttac (|- th) (asl,g)

fails if:

  1) no implications can be derived from the theorem |- th using the
     built-in function RES_CANON (see above).  In this case, IMP_RES_THEN
     fails with the message `no implications`.

  2) one or more implications are derived from |- th, but no resolvents
     can be generated from the list of assumptions asl.  In this case,
     the failure string contains the message: `no resolvents`.

  3) one or more resolvents can be generated, but the function ttac fails
     for EVERY application to these resolvents.  In this case, the
     failure message is `no tactics`.

  4) none of the above is the case, and IMP_RES_THEN does generate one
     or more tactics to be applied in succession to the goal, but one
     of these tactics itself fails.  In this case, the failure string
     from the tactic that failed is propogated.

The tactic RES_THEN has likewise been modified to do only one step in
the resolution process.  Like IMP_RES_THEN, the new _THEN fails
under the conditions as listed above.

See also contrib/resolve.

+----------------------------------------------------------------------------+
| CHANGE TYPE:   New `repeating' function.				     |
|----------------------------------------------------------------------------|
| CHANGED BY:    TFM                                                         |
|----------------------------------------------------------------------------|
| FILES CHANGED: ml/tacont.ml						     |
|----------------------------------------------------------------------------|
| DATE:          17 January 1991					     |
+----------------------------------------------------------------------------+

A new function REPEAT_GTCL has been added to the system.  This function 
is defined by:

   letrec REPEAT_GTCL (ttcl: thm_tactical) ttac th (A,g) =  
       ttcl (REPEAT_GTCL ttcl ttac) th (A,g) ? ttac th (A,g);; 

and is almost identical to the built-in function REPEAT_TCL, whose definition
is equivalent to:

   letrec REPEAT_TCL (ttcl: thm_tactical) ttac th =  
       (ttcl (REPEAT_TCL ttcl ttac) th ? ttac th);; 

The difference is that the new function REPEAT_GTCL is designed to trap
failures of ttcl which are generated only when ttcl is fully applied to
all its arguments, including the goal (A,g):

   ttcl <something> th (A,g)

The primary use of REPEAT_GTCL is for repeating the resolution primitive
IMP_RES_THEN.  An application of this function:

   IMP_RES_THEN ttac th (A,g)

can fail by virtue of the fact that no resolvents can be generated from
the input theorem th and the assumptions A.  Failure for this reason
cannot be generated when IMP_RES_THEN is only partially applied:

   IMP_RES_THEN ttac th

and so REPEAT_TCL cannot, for example, be used to repeat the application
of IMP_RES_THEN until no further resolvents can be generated.  Hence the need
for REPEAT_GTCL, which can be used to trap those failures generated by the
input thm_tactic ttac only when fully applied to both a theorem and a goal.

The above is a rather technical way of saying:

  *** When you want to repeat IMP_RES_THEN until no further resolvents ***
  *** can be generated, use REPEAT_GTCL rather than REPEAT_TCL.	       ***

A preliminary REFERENCE manual exists.

See also contrib/resolve.

+----------------------------------------------------------------------------+
| CHANGE TYPE:   Improvement in `resolution' tactics (IMP_RES_TAC, RES_TAC)  |
|----------------------------------------------------------------------------|
| CHANGED BY:    TFM                                                         |
|----------------------------------------------------------------------------|
| FILES CHANGED: ml/resolve.ml						     |
|----------------------------------------------------------------------------|
| DATE:          17 January 1991					     |
+----------------------------------------------------------------------------+

The tactic IMP_RES_TAC has been reimplemented using the new version of
IMP_RES_THEN discussed above.  The main changes are two:

1: First, the new IMP_RES_TAC does not add itermediate resolvents to
   the assumption list of the goal.  For example, if the theorem supplied
   to IMP_RES_TAC is:


        |- P1 ==> P2 ==> P3 ==> ... Pn ==> Q

   and the resulting tactic is applied to the goal:

        <goal>
        [P1]
        [P2]
        [P3]
         .
         .
         .
        [Pn]
    
   then only the final resolvent "Q" is added to the assumption list:

        <goal>
        [P1]
        [P2]
        [P3]
         .
         .
         .
        [Pn]
        [Q]

   By contrast, the old version of IMP_RES_TAC would give:

        <goal>
        [P1]
        [P2]
        [P3]
         .
         .
         .
        [Pn]
        [P2 ==> P3 ==> ... Pn ==> Q]
        [P3 ==> ... Pn ==> Q]
        [Pn ==> Q]
        [Q]

   as the resulting subgoal.

2: The new IMP_RES_TAC fully strips all (final) resolvents added to the
   assumption list of the goal.  For example:

       IMP_RES_TAC |- P ==> ?x.Q(x)

   applied to the goal:

       <goal>
       [P]

   now gives:

       <goal>
       [P]
       [Q(x)]

   rather than

       <goal>
       [P]
       [?x.Q(x)]

The above remarks also apply to the new version of RES_TAC.

See also contrib/resolve.

+----------------------------------------------------------------------------+
| CHANGE TYPE:   Deletion (FCOND).					     |
|----------------------------------------------------------------------------|
| CHANGED BY:    TFM                                                         |
|----------------------------------------------------------------------------|
| FILES CHANGED: theories/mk_bool.ml ml/hol-rule.ml			     |
|----------------------------------------------------------------------------|
| DATE:          20 January 1991					     |
+----------------------------------------------------------------------------+

The constant FCOND, defined in the theory bool by:

 new_definition
 (`FCOND_DEF`,"FCOND = \f.\f1:*->**.\f2:*->**.\x. COND(f x)(f1 x)(f2 x)");;

was a relic from LCF_LSM, and has now been deleted.

+----------------------------------------------------------------------------+
| CHANGE TYPE:   Deletion (IFF).					     |
|----------------------------------------------------------------------------|
| CHANGED BY:    TFM                                                         |
|----------------------------------------------------------------------------|
| FILES CHANGED: theories/mk_bool.ml ml/hol-rule.ml			     |
|----------------------------------------------------------------------------|
| DATE:          20 January 1991					     |
+----------------------------------------------------------------------------+

The boolean constant <=>, denoting equivalence, is redundant in HOL,
since $=:bool->bool->bool can always be used instead.  There is a 
considerable infrastructure for equality in HOL, and the parallel
infrastructure for <=> merely duplicates some of this.

The constant <=>, defined in the theory bool by:

  new_infix_definition(`IFF_DEF`, "$<=> = \t1 t2. (t1==>t2)/\(t2==>t1)");;

has therefore been deleted, as have all special-purpose inference rules
for this constant.  All relevant parts of the source code have been,
for the time being, merely commented out, so that users wishing to 
reinstate <=> locally may do so.

The deleted objects are:

  mk_iff		(constructor)
  is_iff		(discriminator)
  dest_iff		(destructor)
  IFF_DEF		(definition)
  IFF_EQ_THM1		(theorem)
  IFF_EQ_THM2		(theorem)
  IFF_EQ		(theorem)
  IFF_EQ_RULE		(inference rule)
  CONJ_IFF		(inference rule)
  IFF_CONJ		(inference rule)
  IFF_THEN2		(theorem tactical)
  IFF_THEN		(theorem tactical)
  IFF_TAC		(tactic)

Other affected objects are:

  basic_rewrites	(theorem)
  mk_rewrites		(inference rule)

The REFERENCE manual has been updated accordingly.

+ -------------------------------------------------------------------------- +
| CHANGE TYPE:   New ML flag (print_fasl)				     |
|----------------------------------------------------------------------------|
| CHANGED BY:    TFM/JVT						     |
|----------------------------------------------------------------------------|
| FILES CHANGED: lisp/f-franz.l						     |
|                lisp/f-iox-stand.l					     |
|----------------------------------------------------------------------------|
| DATE:          20 January 1991					     |
+ -------------------------------------------------------------------------- +

When the flag `print_fasl` is false (the default) no message is printed
by lisp when a compiled file is loaded. When it is true, the usual message,
which for Franz has the form:

   [fasl /usr/etc...etc/<file>.o],

is printed.

+----------------------------------------------------------------------------+
| CHANGE TYPE:   New inference rule (IMP_CONJ)				     |
|----------------------------------------------------------------------------|
| CHANGED BY:    TFM                                                         |
|----------------------------------------------------------------------------|
| FILES CHANGED: ml/drul.ml						     |
|----------------------------------------------------------------------------|
| DATE:          21 January 1991					     |
+----------------------------------------------------------------------------+

A new derived inference rule:

  A1 |- P ==> Q    A2 |- R ==> S
 --------------------------------- IMP_CONJ
   A1 u A2 |- P /\ R ==> Q /\ S

has been added to the system.  A preliminary REFERENCE entry exists.


+----------------------------------------------------------------------------+
| CHANGE TYPE:   New inference rule (EXIST_IMP)				     |
|----------------------------------------------------------------------------|
| CHANGED BY:    TFM                                                         |
|----------------------------------------------------------------------------|
| FILES CHANGED: ml/drul.ml						     |
|----------------------------------------------------------------------------|
| DATE:          21 January 1991					     |
+----------------------------------------------------------------------------+

A new derived inference rule:

        A |- P ==> Q
 -------------------------- EXISTS_IMP "x"
   A |- (?x.P) ==> (?x.Q)

has been added to the system.  A preliminary REFERENCE entry exists.



+----------------------------------------------------------------------------+
| CHANGE TYPE:   Revision of library load files.			     |
|----------------------------------------------------------------------------|
| CHANGED BY:    TFM                                                         |
|----------------------------------------------------------------------------|
| FILES CHANGED: Library						     |
|----------------------------------------------------------------------------|
| DATE:          23 January 1991					     |
+----------------------------------------------------------------------------+

The load files for all built-in libraries have been revised to reflect 
the changes (described above) to the search path mechanism.  The standard
load sequence for libraries is now as follows:

1) For libraries containing only ML code (no theories):

       eval unwind convert taut parser prettyp trs 

   the effect of executing:

       load_libarary `<library>`;;

   is simply to load the compiled code from <library> into HOL.
   The HOL search path is not updated. But the help search path
   may be augmented to provide online help for the functions provided
   by the library.

2) For libraries containing theories (and possibly) ML code, the
   load sequence is as follows.  When 

       load_libarary `<library>`;;

   is executed, the following things happen.

      a) augment the search path with the absolute pathname to the
         library.

      b) (optionally) update the help search path.

      c) if user is in DRAFT mode:

           i)   make the library theories new parents of the current theory
           ii)  activate autoloading from library theories
           iii) load any ML code from the library

         otherwise, if the library theories are descendents of the current
         theory:

           i)   make the main library theory the current theory
           ii)  activate autoloading from library theories
           iii) load any ML code from the library

         otherwise, the library theories cannot be loaded yet.  In this
         case, the action taken by load file is to:

           i) define a function which, when called, will activate
              autoloading for the library theories and load the
              library's ML code.

Typical ways in which libaries can be loaded are as follows.

1) create a new theory foo that uses one library.

      load_library `lib`;;		new_theory `foo`;;
      new_theory `foo`			load_library `lib`;;
      ...			or	...
      quit();;				quit();;


2) create a new theory foo that uses two independent libraries.

      new_theory `foo`;;
      load_library `lib1`;;
      load_library `lib2`;;
      ...
      quit();;

3) do some work with theory foo, which depends on two independent
   libraries lib1 and lib2:

      load_library `lib1`;;	% fully loads lib1 %
      load_library `lib2`;;	% just updates search path (*)%
      load_theory `foo`;;

      load_lib2() ;;		% function defined as result of (*) above. %

      % libraries are now fully loaded. %
   
Users should inspect the load file for the string library for an example.

+----------------------------------------------------------------------------+
| CHANGE TYPE:   New function: ancestry					     |
|----------------------------------------------------------------------------|
| CHANGED BY:    TFM                                                         |
|----------------------------------------------------------------------------|
| FILES CHANGED: ml/f-thyfn.l					     	     |
|----------------------------------------------------------------------------|
| DATE:          27 January 1990					     |
+----------------------------------------------------------------------------+

A call to:

   ancestry();;

returns a list of the proper ancestors of the current theory.  This is 
equivalent to

   ancestors `-`;;

but MUCH faster.


+----------------------------------------------------------------------------+
| CHANGE TYPE:   Parser and pretty-printer enhancements                      |
|----------------------------------------------------------------------------|
| CHANGED BY:    MJCG                                                        |
|----------------------------------------------------------------------------|
| FILES CHANGED: lisp/hol-pars.l					     |
|                lisp/hol-writ.l                                             |
|                lisp/f-iox-stand.l (flags)                                  |
|                lisp/f-constants.l (restrict-tok)                           |
|                lisp/f-parser.l (hol-restrictsetup, ::)                     |
|                lisp/parslet.l                                              |
|                lisp/parslist.l                                             |
|                theories/mk_bool.ml                                         |
|----------------------------------------------------------------------------|
| DATE:          24 January 1991					     |
+----------------------------------------------------------------------------+

Syntactic support for restricted quantification and abstraction is now
provided. This follows a suggestion discussed at the Second HOL Users
Meeting and implements a methods of simulating subtypes and dependent
types with predicates. 

Currently no derived rules are provided to support this notation, so
any inferences will need to work on the underlying semantic
representation.

The new syntax automatically translates as follows:

   \v::P. B    <---->   RES_ABTRACT P (\v. B)
   !v::P. B    <---->   RES_FORALL  P (\v. B)
   ?v::P. B    <---->   RES_EXISTS  P (\v. B)
   @v::P. B    <---->   RES_SELECT  P (\v. B)

Anything can be written between the binder and `::` that could be
written between the binder and `.` in the old notation. See the
examples below.

The flag `print_restrict` has default true, but if set to false will
disable the pretty printing. This is useful for seeing what the
semantics of particular restricted abstractions are.

The constants RES_ABSTRACT, RES_FORALL, RES_EXISTS and RES_SELECT are
defined in the theory `bool` by:

   |- RES_ABSTRACT P B =  \x:*. (P x => B x | ARB:**)

   |- RES_FORALL P B   =  !x:*. P x ==> B x

   |- RES_EXISTS P B   =  ?x:*. P x /\ B x

   |- RES_SELECT P B   =  @x:*. P x /\ B x

where ARB is defined in the theory `bool` by:

   |- ARB  =  @x:*. T

User defined binders can also have restricted forms. If B is the name
of a binder and RES_B is the name of a suitable constant (which
must be explicitly defined), then executing:

   associate_restriction(`B`, `RES_B`);;

will cause the parser and pretty-printer to support:

   Bv::P. B    <---->   RES_B  P (\v. B)

Note that associations between user defined binders and their
restrictions are not stored in the theory, so they have to be set up
for each hol session (e.g. with a hol-init.ml file).

Examples of built-in restrictions:

   #"!x y::P. x<y";;
   "!x y :: P. x < y" : term

   #set_flag(`print_restrict`, false);;
   true : bool
   
   #"!x y::P. x<y";;
   "RES_FORALL P(\x. RES_FORALL P(\y. x < y))" : term

   #"?(x,y) p::(\(m,n).m<n). p=(x,y)";;
   "RES_EXISTS
    (\(m,n). m < n)
    (\(x,y). RES_EXISTS(\(m,n). m < n)(\p. p = x,y))"
   : term

   #"\x y z::P.[0;x;y;z]";;
   "RES_ABSTRACT P(\x. RES_ABSTRACT P(\y. RES_ABSTRACT P(\z. [0;x;y;z])))"
   : term

A conversion that rewrites away the constants RES_ABSTRACT,
RES_FORALL, RES_EXISTS and RES_SELECT is:

   let RESTRICT_CONV =
    DEPTH_CONV
     (REWRITE_CONV (definition `bool` `RES_ABSTRACT`) ORELSEC
      REWRITE_CONV (definition `bool` `RES_FORALL`)   ORELSEC
      REWRITE_CONV (definition `bool` `RES_EXISTS`)   ORELSEC
      REWRITE_CONV (definition `bool` `RES_SELECT`))
    THENC DEPTH_CONV BETA_CONV;;

This is a bit unsatisfactory, as is shown by the example below:

   #let t = "!x y::P.?f:num->num::Q. f(@n::R.T) = (x+y)";;
   t = "!x y :: P. ?f :: Q. f(@n :: R. T) = x + y" : term

   #RESTRICT_CONV t;;
   |- (!x y :: P. ?f :: Q. f(@n :: R. T) = x + y) =
      (!x. P x ==> (!x'. P x' ==> (?x. Q x /\ (x(@x. R x /\ T) = x + x'))))

The variable "x" in the definitions of RES_ABSTRACT, RES_FORALL,
RES_EXISTS and RES_SELECT gets confused with the variable in t.  This
can be avoided by changing RESTRICT_CONV to perform explicit
alpha-conversion. For example:

   RES_FORALL P (\v. B[v]) ---> !v. P v ==> B[v]

This is straightforward (but not yet implemented). Dealing with the case when
v is a variable structure is also desirable. For example:

   #let t1 = "!(m,n)::P. m<n";;
   t1 = "!(m,n) :: P. m < n" : term

   #RESTRICT_CONV t1;;
   |- (!(m,n) :: P. m < n) = (!x. P x ==> (\(m,n). m < n)x)

If anyone writes the desired conversions please let us know!

Example of a user-defined restriction:

   #new_binder_definition(`DURING`, "DURING(p:num#num->bool) = $!p");;
   |- !p. $DURING p = $! p

   #"DURING x::(m,n). p x";;
   no restriction constant associated with DURING
   skipping: x " ;; parse failed     

   #new_definition
   # (`RES_DURING`, "RES_DURING(m,n)p = !x. m<=x /\ x<=n ==> p x");;
   |- !m n p. RES_DURING(m,n)p = (!x. m <= x /\ x <= n ==> p x)

   #associate_restriction(`DURING`,`RES_DURING`);;
   () : void

   #"DURING x::(m,n). p x";;
   "DURING x :: (m,n). p x" : term

   #set_flag(`print_restrict`,false);;
   true : bool

   #"DURING x::(m,n). p x";;
   "RES_DURING(m,n)(\x. p x)" : term

+----------------------------------------------------------------------------+
| CHANGE TYPE:   Withdrawal of libraries.				     |
|----------------------------------------------------------------------------|
| CHANGED BY:    TFM                                                         |
|----------------------------------------------------------------------------|
| FILES CHANGED: Library						     |
|----------------------------------------------------------------------------|
| DATE:          30 January 1991					     |
+----------------------------------------------------------------------------+


Four libraries from version 1.11 of HOL have been temporarily withdrawn,
because the Cambridge group have been unable to rebuild them in HOL version 12,
namely:

   card   well_order   zet   csp

The first three are difficult to rebuild because of changes in version 12 to
resolution.  They rely very heavily on the order in which the assumptions of
goals appear, and can be updated for version 12 only by their author.  

The fourth library uses the set library, which has been substantially
modified in version 12.  This library must likewise be revised by its 
author.


+----------------------------------------------------------------------------+
| CHANGE TYPE:   New built-in theorems (dist. laws for /\ and \/)	     |
|----------------------------------------------------------------------------|
| CHANGED BY:    TFM                                                         |
|----------------------------------------------------------------------------|
| FILES CHANGED: drul.ml						     |
|----------------------------------------------------------------------------|
| DATE:          2 February 1991					     |
+----------------------------------------------------------------------------+

The theorems:

  LEFT_AND_OVER_OR   |- !t1 t2 t3. t1 /\ (t2 \/ t3) = t1 /\ t2 \/ t1 /\ t3
  
  RIGHT_AND_OVER_OR  |- !t1 t2 t3. (t2 \/ t3) /\ t1 = t2 /\ t1 \/ t3 /\ t1

  LEFT_OR_OVER_AND   |- !t1 t2 t3. t1 \/ t2 /\ t3 = (t1 \/ t2) /\ (t1 \/ t3)
  
  RIGHT_OR_OVER_AND  |- !t1 t2 t3. t2 /\ t3 \/ t1 = (t2 \/ t1) /\ (t3 \/ t1)

are now built in. The REFERENCE manual has been updated.


+----------------------------------------------------------------------------+
| CHANGE TYPE:   Bugfix (REFL_TAC)					     |
|----------------------------------------------------------------------------|
| CHANGED BY:    TFM                                                         |
|----------------------------------------------------------------------------|
| FILES CHANGED: tactics.ml						     |
|----------------------------------------------------------------------------|
| DATE:          2 February 1991					     |
+----------------------------------------------------------------------------+

The tactic:

      A = A
    =========  REFL_TAC
        -
has been revised so that assumptions are preserved and so that it deals
properly with alpha-equivalence.  In previous versions of HOL, REFL_TAC 
would solve the goal A = A' where A' is alpha-equivalent to A, but the 
resulting proof would produce the theorem |- A = A, not |- A = A'.  The
new version now proves the latter result.  Furthermore, when proving a 
goal with assumptions:

   ASL, A = A

the resulting proof in previous implementations of REFL_TAC would prove:

   |- A = A

and not

   ASL |- A = A

That is, assumptions would disappear (being not needed for the proof). The
new version proves ASL |- A = A, as expected.

+----------------------------------------------------------------------------+
| CHANGE TYPE:   New tactic (AP_THM_TAC)				     |
|----------------------------------------------------------------------------|
| CHANGED BY:    TFM                                                         |
|----------------------------------------------------------------------------|
| FILES CHANGED: tactics.ml						     |
|----------------------------------------------------------------------------|
| DATE:          4 February 1991					     |
+----------------------------------------------------------------------------+

AP_THM_TAC inverts the AP_THM inference rule:

   f x = g x
 =============   AP_THM_TAC
     f = g

A preliminary REFERENCE entry exists.

+----------------------------------------------------------------------------+
| CHANGE TYPE:   Deletion (EXISTS_REFL_TAC)				     |
|----------------------------------------------------------------------------|
| CHANGED BY:    TFM                                                         |
|----------------------------------------------------------------------------|
| FILES CHANGED: tactics.ml						     |
|----------------------------------------------------------------------------|
| DATE:          4 February 1991					     |
+----------------------------------------------------------------------------+

The tactic EXISTS_REFL_TAC has been temporarily deleted (commented-out in the
source) pending replacement by a proper reimplmentation.


+----------------------------------------------------------------------------+
| CHANGE TYPE:   Bug fix (ascii_code)					     |
|----------------------------------------------------------------------------|
| CHANGED BY:    MJCG                                                        |
|----------------------------------------------------------------------------|
| FILES CHANGED: lisp/f-dml.l						     |
|----------------------------------------------------------------------------|
| DATE:          19 February 1991					     |
+----------------------------------------------------------------------------+

The ML function ascii_code now fails (with token `ascii_code`) when
applied to the empty string (previously it caused an error).

N.B. ascii_code may still not work in Common Lisp versions of HOL
     (a Common Lisp implementation of Franz's cascii may be needed).


+----------------------------------------------------------------------------+
| CHANGE TYPE:   New ML function (is_ml_infix)				     |
|----------------------------------------------------------------------------|
| CHANGED BY:    MJCG                                                        |
|----------------------------------------------------------------------------|
| FILES CHANGED: lisp/f-dml.l						     |
|----------------------------------------------------------------------------|
| DATE:          19 February 1991					     |
+----------------------------------------------------------------------------+

is_ml_infix tests whether a string is the name of a built-in or user-defined
ML infix. A reference entry exists.



