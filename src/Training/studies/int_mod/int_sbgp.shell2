faulkner% hol88

       _  _    __    _      __    __
|___   |__|   |  |   |     |__|  |__|
|      |  |   |__|   |__   |__|  |__|

  Version 1.07, built on Jul 13 1989

#load_theory `int_sbgp`;;
Theory int_sbgp loaded
() : void

#load_library `group`;;
Loading library `group` ...
[fasl /home/unagi/elsa/hol/hol88/Library/group/group_ml.o]
.[fasl /home/unagi/elsa/hol/hol88/Library/group/start_groups_ml.o]
..........................................[fasl /home/unagi/elsa/hol/hol88/Library/group/group_tac_ml.o]

[fasl /home/unagi/elsa/hol/hol88/Library/group/start_groups_ml.o]
.......................................() : void

GROUP_TAC = - : (thm list -> tactic)

GROUP_ELT_TAC = - : tactic

GROUP_RIGHT_ASSOC_TAC = - : (term -> tactic)

GROUP_LEFT_ASSOC_TAC = - : (term -> tactic)

File group_tac loaded
.[fasl /home/unagi/elsa/hol/hol88/Library/group/inst_gp_ml.o]

[fasl /home/unagi/elsa/hol/hol88/Library/group/start_groups_ml.o]
.......................................() : void

return_GROUP_thm = - : (string -> thm -> proof)

include_GROUP_thm = - : (string -> string -> thm -> proof)

return_GROUP_theory = 
-
: (string -> thm -> thm list -> (string # thm) list)

include_GROUP_theory = - : (string -> thm -> thm list -> void)

File inst_gp loaded
.
Library `group` loaded.
() : void

#load_library `integer`;;
Loading library `integer` ...
[fasl /home/unagi/elsa/hol/hol88/Library/integer/integer_ml.o]
.[fasl /home/unagi/elsa/hol/hol88/Library/group/start_groups_ml.o]
........................................[fasl /home/unagi/elsa/hol/hol88/Library/integer/num_tac_ml.o]

[fasl /home/unagi/elsa/hol/hol88/Library/group/start_groups_ml.o]
.......................................() : void

GEN_INDUCT_RULE = - : (thm -> thm -> thm)

GEN_INDUCT_TAC = - : tactic

File num_tac loaded
.[fasl /home/unagi/elsa/hol/hol88/Library/integer/integer_tac_ml.o]

[fasl /home/unagi/elsa/hol/hol88/Library/group/start_groups_ml.o]
.......................................() : void

INT_CASES_RULE = - : (thm -> thm -> thm)

INT_CASES_TAC = - : tactic

SIMPLE_INT_CASES_RULE = - : (thm -> thm -> thm -> thm)

SIMPLE_INT_CASES_TAC = - : tactic

INT_MIN_RULE = - : (thm -> thm -> thm)

INT_MIN_TAC = - : (term -> tactic)

INT_MAX_RULE = - : (thm -> thm -> thm)

INT_MAX_TAC = - : (term -> tactic)

INT_RIGHT_ASSOC_TAC = - : (term -> tactic)

INT_LEFT_ASSOC_TAC = - : (term -> tactic)

File integer_tac loaded
...
Library `integer` loaded.
() : void

#include_theory `int_sbgp`;;
() : void

#set_goal([],"!H. SUBGROUP((\N.T),$plus)H ==> 
#                  !m p. H p ==> H (m times p)");;
"!H. SUBGROUP((\N. T),$plus)H ==> (!m p. H p ==> H(m times p))"

() : void

#expand (GEN_TAC THEN DISCH_TAC);;
OK..
"!m p. H p ==> H(m times p)"
    [ "SUBGROUP((\N. T),$plus)H" ]

() : void

#expand (FIRST_ASSUM \thm. (STRIP_ASSUME_TAC
#     (PURE_ONCE_REWRITE_RULE [SUBGROUP_DEF] thm)));;
Definition SUBGROUP_DEF autoloaded from theory `more_gp`.
SUBGROUP_DEF = 
|- !G prod H.
    SUBGROUP(G,prod)H =
    GROUP(G,prod) /\ (!x. H x ==> G x) /\ GROUP(H,prod)

OK..
"!m p. H p ==> H(m times p)"
    [ "SUBGROUP((\N. T),$plus)H" ]
    [ "GROUP((\N. T),$plus)" ]
    [ "!x. H x ==> (\N. T)x" ]
    [ "GROUP(H,$plus)" ]

() : void

#expand INT_CASES_TAC;;
OK..
2 subgoals
"!n2 p. H p ==> H((neg(INT n2)) times p)"
    [ "SUBGROUP((\N. T),$plus)H" ]
    [ "GROUP((\N. T),$plus)" ]
    [ "!x. H x ==> (\N. T)x" ]
    [ "GROUP(H,$plus)" ]
    [ "!n1 p. H p ==> H((INT n1) times p)" ]

"!n1 p. H p ==> H((INT n1) times p)"
    [ "SUBGROUP((\N. T),$plus)H" ]
    [ "GROUP((\N. T),$plus)" ]
    [ "!x. H x ==> (\N. T)x" ]
    [ "GROUP(H,$plus)" ]

() : void

#expand INDUCT_TAC;;
OK..
2 subgoals
"!p. H p ==> H((INT(SUC n1)) times p)"
    [ "SUBGROUP((\N. T),$plus)H" ]
    [ "GROUP((\N. T),$plus)" ]
    [ "!x. H x ==> (\N. T)x" ]
    [ "GROUP(H,$plus)" ]
    [ "!p. H p ==> H((INT n1) times p)" ]

"!p. H p ==> H((INT 0) times p)"
    [ "SUBGROUP((\N. T),$plus)H" ]
    [ "GROUP((\N. T),$plus)" ]
    [ "!x. H x ==> (\N. T)x" ]
    [ "GROUP(H,$plus)" ]

() : void

#expand ((REPEAT STRIP_TAC) THEN
#  (REWRITE_TAC[TIMES_ZERO;(UNDISCH (SPEC_ALL INT_SBGP_ZERO))]));;
Theorem INT_SBGP_ZERO autoloaded from theory `int_sbgp`.
INT_SBGP_ZERO = |- !H. SUBGROUP((\N. T),$plus)H ==> H(INT 0)

Theorem TIMES_ZERO autoloaded from theory `integer`.
TIMES_ZERO = 
|- !M. (M times (INT 0) = INT 0) /\ ((INT 0) times M = INT 0)

OK..
goal proved
. |- !p. H p ==> H((INT 0) times p)

Previous subproof:
"!p. H p ==> H((INT(SUC n1)) times p)"
    [ "SUBGROUP((\N. T),$plus)H" ]
    [ "GROUP((\N. T),$plus)" ]
    [ "!x. H x ==> (\N. T)x" ]
    [ "GROUP(H,$plus)" ]
    [ "!p. H p ==> H((INT n1) times p)" ]

() : void

#expand (GEN_TAC THEN DISCH_TAC THEN RES_TAC);;
OK..
"H((INT(SUC n1)) times p)"
    [ "SUBGROUP((\N. T),$plus)H" ]
    [ "GROUP((\N. T),$plus)" ]
    [ "!x. H x ==> (\N. T)x" ]
    [ "GROUP(H,$plus)" ]
    [ "!p. H p ==> H((INT n1) times p)" ]
    [ "H p" ]
    [ "H((INT n1) times p)" ]
    [ "(\N. T)((INT n1) times p)" ]
    [ "(\N. T)p" ]

() : void

#expand (PURE_REWRITE_TAC[ADD1;(SYM (SPEC_ALL NUM_ADD_IS_INT_ADD))]);;
Theorem NUM_ADD_IS_INT_ADD autoloaded from theory `integer`.
NUM_ADD_IS_INT_ADD = |- !m n. (INT m) plus (INT n) = INT(m + n)

Theorem ADD1 autoloaded from theory `arithmetic`.
ADD1 = |- !m. SUC m = m + 1

OK..
"H(((INT n1) plus (INT 1)) times p)"
    [ "SUBGROUP((\N. T),$plus)H" ]
    [ "GROUP((\N. T),$plus)" ]
    [ "!x. H x ==> (\N. T)x" ]
    [ "GROUP(H,$plus)" ]
    [ "!p. H p ==> H((INT n1) times p)" ]
    [ "H p" ]
    [ "H((INT n1) times p)" ]
    [ "(\N. T)((INT n1) times p)" ]
    [ "(\N. T)p" ]

() : void

#expand (PURE_REWRITE_TAC[RIGHT_PLUS_DISTRIB;TIMES_IDENTITY]);;
Theorem TIMES_IDENTITY autoloaded from theory `integer`.
TIMES_IDENTITY = |- !M. (M times (INT 1) = M) /\ ((INT 1) times M = M)

Theorem RIGHT_PLUS_DISTRIB autoloaded from theory `integer`.
RIGHT_PLUS_DISTRIB = 
|- !M N P. (M plus N) times P = (M times P) plus (N times P)

OK..
"H(((INT n1) times p) plus p)"
    [ "SUBGROUP((\N. T),$plus)H" ]
    [ "GROUP((\N. T),$plus)" ]
    [ "!x. H x ==> (\N. T)x" ]
    [ "GROUP(H,$plus)" ]
    [ "!p. H p ==> H((INT n1) times p)" ]
    [ "H p" ]
    [ "H((INT n1) times p)" ]
    [ "(\N. T)((INT n1) times p)" ]
    [ "(\N. T)p" ]

() : void

#expand GROUP_ELT_TAC;;
OK..
goal proved
... |- H(((INT n1) times p) plus p)
... |- H(((INT n1) plus (INT 1)) times p)
... |- H((INT(SUC n1)) times p)
... |- !p. H p ==> H((INT(SUC n1)) times p)
... |- !n1 p. H p ==> H((INT n1) times p)

Previous subproof:
"!n2 p. H p ==> H((neg(INT n2)) times p)"
    [ "SUBGROUP((\N. T),$plus)H" ]
    [ "GROUP((\N. T),$plus)" ]
    [ "!x. H x ==> (\N. T)x" ]
    [ "GROUP(H,$plus)" ]
    [ "!n1 p. H p ==> H((INT n1) times p)" ]

() : void

#expand ((REPEAT STRIP_TAC) THEN
#  (PURE_ONCE_REWRITE_TAC[TIMES_neg]) THEN
#  (MATCH_MP_IMP_TAC (UNDISCH (SPEC_ALL INT_SBGP_neg))));;
Theorem INT_SBGP_neg autoloaded from theory `int_sbgp`.
INT_SBGP_neg = 
|- !H. SUBGROUP((\N. T),$plus)H ==> (!N. H N ==> H(neg N))

Theorem TIMES_neg autoloaded from theory `integer`.
TIMES_neg = 
|- (!M N. M times (neg N) = neg(M times N)) /\
   (!M N. (neg M) times N = neg(M times N))

OK..
"H((INT n2) times p)"
    [ "SUBGROUP((\N. T),$plus)H" ]
    [ "GROUP((\N. T),$plus)" ]
    [ "!x. H x ==> (\N. T)x" ]
    [ "GROUP(H,$plus)" ]
    [ "!n1 p. H p ==> H((INT n1) times p)" ]
    [ "H p" ]

() : void

#expand (NEW_MATCH_ACCEPT_TAC (UNDISCH (SPEC_ALL
#   (ASSUME "!n1 p. H p ==> H((INT n1) times p)"))));;
OK..
goal proved
.. |- H((INT n2) times p)
.. |- !n2 p. H p ==> H((neg(INT n2)) times p)
... |- !m p. H p ==> H(m times p)
. |- !m p. H p ==> H(m times p)
|- !H. SUBGROUP((\N. T),$plus)H ==> (!m p. H p ==> H(m times p))

Previous subproof:
goal proved
() : void


#let INT_SBGP_TIMES_CLOSED = prove_thm(`INT_SBGP_TIMES_CLOSED`,
#"!H. SUBGROUP((\N.T),$plus)H ==> !m p. H p ==> H (m times p)",
#(GEN_TAC THEN DISCH_TAC THEN
# (FIRST_ASSUM \thm.(STRIP_ASSUME_TAC
#   (PURE_ONCE_REWRITE_RULE[SUBGROUP_DEF] thm))) THEN
# INT_CASES_TAC THENL
# [(INDUCT_TAC THENL
#   [((REPEAT STRIP_TAC) THEN
#     (REWRITE_TAC[TIMES_ZERO;(UNDISCH (SPEC_ALL INT_SBGP_ZERO))]));
#    (GEN_TAC THEN DISCH_TAC THEN RES_TAC THEN
#     (PURE_REWRITE_TAC[ADD1;(SYM (SPEC_ALL NUM_ADD_IS_INT_ADD))]) THEN
#     (PURE_REWRITE_TAC[RIGHT_PLUS_DISTRIB;TIMES_IDENTITY]) THEN
#     GROUP_ELT_TAC)]);
#  ((REPEAT STRIP_TAC) THEN
#   (PURE_ONCE_REWRITE_TAC[TIMES_neg]) THEN
#   (MATCH_MP_IMP_TAC (UNDISCH (SPEC_ALL INT_SBGP_neg))) THEN
#   (NEW_MATCH_ACCEPT_TAC (UNDISCH (SPEC_ALL
#     (ASSUME "!n1 p. H p ==> H((INT n1) times p)")))))]));;
INT_SBGP_TIMES_CLOSED = 
|- !H. SUBGROUP((\N. T),$plus)H ==> (!m p. H p ==> H(m times p))

#set_goal([],"!H. SUBGROUP((\N.T),$plus)H ==>
#              ? n.(H = int_mult_set (INT n))");;
"!H. SUBGROUP((\N. T),$plus)H ==> (?n. H = int_mult_set(INT n))"

() : void

#expand (GEN_TAC THEN DISCH_TAC THEN
#  (FIRST_ASSUM
#   \thm.(STRIP_ASSUME_TAC
#     (PURE_ONCE_REWRITE_RULE[SUBGROUP_DEF] thm))));;
OK..
"?n. H = int_mult_set(INT n)"
    [ "SUBGROUP((\N. T),$plus)H" ]
    [ "GROUP((\N. T),$plus)" ]
    [ "!x. H x ==> (\N. T)x" ]
    [ "GROUP(H,$plus)" ]

() : void

#expand ((PURE_ONCE_REWRITE_TAC [INT_MULT_SET_DEF]) THEN
# (ASM_CASES_TAC "!m1. (H m1) ==> (m1 = (INT 0))"));;
Definition INT_MULT_SET_DEF autoloaded from theory `int_sbgp`.
INT_MULT_SET_DEF = |- !n. int_mult_set n = (\m. ?p. m = p times n)

OK..
2 subgoals
"?n. H = (\m. ?p. m = p times (INT n))"
    [ "SUBGROUP((\N. T),$plus)H" ]
    [ "GROUP((\N. T),$plus)" ]
    [ "!x. H x ==> (\N. T)x" ]
    [ "GROUP(H,$plus)" ]
    [ "~(!m1. H m1 ==> (m1 = INT 0))" ]

"?n. H = (\m. ?p. m = p times (INT n))"
    [ "SUBGROUP((\N. T),$plus)H" ]
    [ "GROUP((\N. T),$plus)" ]
    [ "!x. H x ==> (\N. T)x" ]
    [ "GROUP(H,$plus)" ]
    [ "!m1. H m1 ==> (m1 = INT 0)" ]

() : void

#expand (EXISTS_TAC "0");;
OK..
"H = (\m. ?p. m = p times (INT 0))"
    [ "SUBGROUP((\N. T),$plus)H" ]
    [ "GROUP((\N. T),$plus)" ]
    [ "!x. H x ==> (\N. T)x" ]
    [ "GROUP(H,$plus)" ]
    [ "!m1. H m1 ==> (m1 = INT 0)" ]

() : void

#expand ((EXT_TAC "m1:integer") THEN BETA_TAC);;
OK..
"!m1. H m1 = (?p. m1 = p times (INT 0))"
    [ "SUBGROUP((\N. T),$plus)H" ]
    [ "GROUP((\N. T),$plus)" ]
    [ "!x. H x ==> (\N. T)x" ]
    [ "GROUP(H,$plus)" ]
    [ "!m1. H m1 ==> (m1 = INT 0)" ]

() : void

#expand (REWRITE_TAC [TIMES_ZERO]);;
OK..
"!m1. H m1 = (m1 = INT 0)"
    [ "SUBGROUP((\N. T),$plus)H" ]
    [ "GROUP((\N. T),$plus)" ]
    [ "!x. H x ==> (\N. T)x" ]
    [ "GROUP(H,$plus)" ]
    [ "!m1. H m1 ==> (m1 = INT 0)" ]

() : void

#expand (GEN_TAC THEN EQ_TAC);;
OK..
2 subgoals
"(m1 = INT 0) ==> H m1"
    [ "SUBGROUP((\N. T),$plus)H" ]
    [ "GROUP((\N. T),$plus)" ]
    [ "!x. H x ==> (\N. T)x" ]
    [ "GROUP(H,$plus)" ]
    [ "!m1. H m1 ==> (m1 = INT 0)" ]

"H m1 ==> (m1 = INT 0)"
    [ "SUBGROUP((\N. T),$plus)H" ]
    [ "GROUP((\N. T),$plus)" ]
    [ "!x. H x ==> (\N. T)x" ]
    [ "GROUP(H,$plus)" ]
    [ "!m1. H m1 ==> (m1 = INT 0)" ]

() : void

#expand (FIRST_ASSUM (\thm.(ACCEPT_TAC (SPEC_ALL thm))));;
OK..
goal proved
. |- H m1 ==> (m1 = INT 0)

Previous subproof:
"(m1 = INT 0) ==> H m1"
    [ "SUBGROUP((\N. T),$plus)H" ]
    [ "GROUP((\N. T),$plus)" ]
    [ "!x. H x ==> (\N. T)x" ]
    [ "GROUP(H,$plus)" ]
    [ "!m1. H m1 ==> (m1 = INT 0)" ]

() : void

#expand (DISCH_TAC THEN
#  (ASM_REWRITE_TAC [(UNDISCH (SPEC_ALL INT_SBGP_ZERO))]));;
OK..
goal proved
. |- (m1 = INT 0) ==> H m1
.. |- !m1. H m1 = (m1 = INT 0)
.. |- !m1. H m1 = (?p. m1 = p times (INT 0))
.. |- H = (\m. ?p. m = p times (INT 0))
.. |- ?n. H = (\m. ?p. m = p times (INT n))

Previous subproof:
"?n. H = (\m. ?p. m = p times (INT n))"
    [ "SUBGROUP((\N. T),$plus)H" ]
    [ "GROUP((\N. T),$plus)" ]
    [ "!x. H x ==> (\N. T)x" ]
    [ "GROUP(H,$plus)" ]
    [ "~(!m1. H m1 ==> (m1 = INT 0))" ]

() : void

#expand (INT_MIN_TAC "\N. (POS N /\ H N)");;
OK..
3 subgoals
"?LB. !N. N below LB ==> ~(POS N /\ H N)"
    [ "SUBGROUP((\N. T),$plus)H" ]
    [ "GROUP((\N. T),$plus)" ]
    [ "!x. H x ==> (\N. T)x" ]
    [ "GROUP(H,$plus)" ]
    [ "~(!m1. H m1 ==> (m1 = INT 0))" ]
    [ "POS M /\ H M" ]

"?M. POS M /\ H M"
    [ "SUBGROUP((\N. T),$plus)H" ]
    [ "GROUP((\N. T),$plus)" ]
    [ "!x. H x ==> (\N. T)x" ]
    [ "GROUP(H,$plus)" ]
    [ "~(!m1. H m1 ==> (m1 = INT 0))" ]

"?n. H = (\m. ?p. m = p times (INT n))"
    [ "SUBGROUP((\N. T),$plus)H" ]
    [ "GROUP((\N. T),$plus)" ]
    [ "!x. H x ==> (\N. T)x" ]
    [ "GROUP(H,$plus)" ]
    [ "~(!m1. H m1 ==> (m1 = INT 0))" ]
    [ "!N. N below MIN ==> ~(POS N /\ H N)" ]
    [ "POS MIN /\ H MIN" ]

() : void

#expand (POP_ASSUM STRIP_ASSUME_TAC);;
OK..
"?n. H = (\m. ?p. m = p times (INT n))"
    [ "SUBGROUP((\N. T),$plus)H" ]
    [ "GROUP((\N. T),$plus)" ]
    [ "!x. H x ==> (\N. T)x" ]
    [ "GROUP(H,$plus)" ]
    [ "~(!m1. H m1 ==> (m1 = INT 0))" ]
    [ "!N. N below MIN ==> ~(POS N /\ H N)" ]
    [ "POS MIN" ]
    [ "H MIN" ]

() : void

#expand (SUPPOSE_TAC "?n. (INT n) = MIN");;
OK..
2 subgoals
"?n. INT n = MIN"
    [ "SUBGROUP((\N. T),$plus)H" ]
    [ "GROUP((\N. T),$plus)" ]
    [ "!x. H x ==> (\N. T)x" ]
    [ "GROUP(H,$plus)" ]
    [ "~(!m1. H m1 ==> (m1 = INT 0))" ]
    [ "!N. N below MIN ==> ~(POS N /\ H N)" ]
    [ "POS MIN" ]
    [ "H MIN" ]

"?n. H = (\m. ?p. m = p times (INT n))"
    [ "SUBGROUP((\N. T),$plus)H" ]
    [ "GROUP((\N. T),$plus)" ]
    [ "!x. H x ==> (\N. T)x" ]
    [ "GROUP(H,$plus)" ]
    [ "~(!m1. H m1 ==> (m1 = INT 0))" ]
    [ "!N. N below MIN ==> ~(POS N /\ H N)" ]
    [ "POS MIN" ]
    [ "H MIN" ]
    [ "?n. INT n = MIN" ]

() : void

#expand (POP_ASSUM STRIP_ASSUME_TAC);;
OK..
"?n. H = (\m. ?p. m = p times (INT n))"
    [ "SUBGROUP((\N. T),$plus)H" ]
    [ "GROUP((\N. T),$plus)" ]
    [ "!x. H x ==> (\N. T)x" ]
    [ "GROUP(H,$plus)" ]
    [ "~(!m1. H m1 ==> (m1 = INT 0))" ]
    [ "!N. N below MIN ==> ~(POS N /\ H N)" ]
    [ "POS MIN" ]
    [ "H MIN" ]
    [ "INT n = MIN" ]

() : void

#expand (EXISTS_TAC "n:num");;
OK..
"H = (\m. ?p. m = p times (INT n))"
    [ "SUBGROUP((\N. T),$plus)H" ]
    [ "GROUP((\N. T),$plus)" ]
    [ "!x. H x ==> (\N. T)x" ]
    [ "GROUP(H,$plus)" ]
    [ "~(!m1. H m1 ==> (m1 = INT 0))" ]
    [ "!N. N below MIN ==> ~(POS N /\ H N)" ]
    [ "POS MIN" ]
    [ "H MIN" ]
    [ "INT n = MIN" ]

() : void

#expand (POP_ASSUM \thm. PURE_ONCE_REWRITE_TAC [thm]);;
OK..
"H = (\m. ?p. m = p times MIN)"
    [ "SUBGROUP((\N. T),$plus)H" ]
    [ "GROUP((\N. T),$plus)" ]
    [ "!x. H x ==> (\N. T)x" ]
    [ "GROUP(H,$plus)" ]
    [ "~(!m1. H m1 ==> (m1 = INT 0))" ]
    [ "!N. N below MIN ==> ~(POS N /\ H N)" ]
    [ "POS MIN" ]
    [ "H MIN" ]

() : void

#expand ((EXT_TAC "m:integer") THEN BETA_TAC THEN
#  GEN_TAC THEN EQ_TAC);; 
OK..
2 subgoals
"(?p. m = p times MIN) ==> H m"
    [ "SUBGROUP((\N. T),$plus)H" ]
    [ "GROUP((\N. T),$plus)" ]
    [ "!x. H x ==> (\N. T)x" ]
    [ "GROUP(H,$plus)" ]
    [ "~(!m1. H m1 ==> (m1 = INT 0))" ]
    [ "!N. N below MIN ==> ~(POS N /\ H N)" ]
    [ "POS MIN" ]
    [ "H MIN" ]

"H m ==> (?p. m = p times MIN)"
    [ "SUBGROUP((\N. T),$plus)H" ]
    [ "GROUP((\N. T),$plus)" ]
    [ "!x. H x ==> (\N. T)x" ]
    [ "GROUP(H,$plus)" ]
    [ "~(!m1. H m1 ==> (m1 = INT 0))" ]
    [ "!N. N below MIN ==> ~(POS N /\ H N)" ]
    [ "POS MIN" ]
    [ "H MIN" ]

() : void

#expand ((SPEC_TAC ("m:integer","N:integer")) THEN SIMPLE_INT_CASES_TAC);;
OK..
3 subgoals
"H(INT 0) ==> (?p. INT 0 = p times MIN)"
    [ "SUBGROUP((\N. T),$plus)H" ]
    [ "GROUP((\N. T),$plus)" ]
    [ "!x. H x ==> (\N. T)x" ]
    [ "GROUP(H,$plus)" ]
    [ "~(!m1. H m1 ==> (m1 = INT 0))" ]
    [ "!N. N below MIN ==> ~(POS N /\ H N)" ]
    [ "POS MIN" ]
    [ "H MIN" ]

"!N. NEG N ==> H N ==> (?p. N = p times MIN)"
    [ "SUBGROUP((\N. T),$plus)H" ]
    [ "GROUP((\N. T),$plus)" ]
    [ "!x. H x ==> (\N. T)x" ]
    [ "GROUP(H,$plus)" ]
    [ "~(!m1. H m1 ==> (m1 = INT 0))" ]
    [ "!N. N below MIN ==> ~(POS N /\ H N)" ]
    [ "POS MIN" ]
    [ "H MIN" ]
    [ "!N. POS N ==> H N ==> (?p. N = p times MIN)" ]

"!N. POS N ==> H N ==> (?p. N = p times MIN)"
    [ "SUBGROUP((\N. T),$plus)H" ]
    [ "GROUP((\N. T),$plus)" ]
    [ "!x. H x ==> (\N. T)x" ]
    [ "GROUP(H,$plus)" ]
    [ "~(!m1. H m1 ==> (m1 = INT 0))" ]
    [ "!N. N below MIN ==> ~(POS N /\ H N)" ]
    [ "POS MIN" ]
    [ "H MIN" ]

() : void

#expand (REPEAT STRIP_TAC);;
OK..
"?p. N = p times MIN"
    [ "SUBGROUP((\N. T),$plus)H" ]
    [ "GROUP((\N. T),$plus)" ]
    [ "!x. H x ==> (\N. T)x" ]
    [ "GROUP(H,$plus)" ]
    [ "~(!m1. H m1 ==> (m1 = INT 0))" ]
    [ "!N. N below MIN ==> ~(POS N /\ H N)" ]
    [ "POS MIN" ]
    [ "H MIN" ]
    [ "POS N" ]
    [ "H N" ]

() : void

#expand (INT_MAX_TAC "\X.~(NEG(N minus (X times MIN)))");;
OK..
3 subgoals
"?UB. !N'. UB below N' ==> ~~NEG(N minus (N' times MIN))"
    [ "SUBGROUP((\N. T),$plus)H" ]
    [ "GROUP((\N. T),$plus)" ]
    [ "!x. H x ==> (\N. T)x" ]
    [ "GROUP(H,$plus)" ]
    [ "~(!m1. H m1 ==> (m1 = INT 0))" ]
    [ "!N. N below MIN ==> ~(POS N /\ H N)" ]
    [ "POS MIN" ]
    [ "H MIN" ]
    [ "POS N" ]
    [ "H N" ]
    [ "~NEG(N minus (M times MIN))" ]

"?M. ~NEG(N minus (M times MIN))"
    [ "SUBGROUP((\N. T),$plus)H" ]
    [ "GROUP((\N. T),$plus)" ]
    [ "!x. H x ==> (\N. T)x" ]
    [ "GROUP(H,$plus)" ]
    [ "~(!m1. H m1 ==> (m1 = INT 0))" ]
    [ "!N. N below MIN ==> ~(POS N /\ H N)" ]
    [ "POS MIN" ]
    [ "H MIN" ]
    [ "POS N" ]
    [ "H N" ]

"?p. N = p times MIN"
    [ "SUBGROUP((\N. T),$plus)H" ]
    [ "GROUP((\N. T),$plus)" ]
    [ "!x. H x ==> (\N. T)x" ]
    [ "GROUP(H,$plus)" ]
    [ "~(!m1. H m1 ==> (m1 = INT 0))" ]
    [ "!N. N below MIN ==> ~(POS N /\ H N)" ]
    [ "POS MIN" ]
    [ "H MIN" ]
    [ "POS N" ]
    [ "H N" ]
    [ "!N'. MAX below N' ==> ~~NEG(N minus (N' times MIN))" ]
    [ "~NEG(N minus (MAX times MIN))" ]

() : void

#expand (EXISTS_TAC "MAX:integer");;
OK..
"N = MAX times MIN"
    [ "SUBGROUP((\N. T),$plus)H" ]
    [ "GROUP((\N. T),$plus)" ]
    [ "!x. H x ==> (\N. T)x" ]
    [ "GROUP(H,$plus)" ]
    [ "~(!m1. H m1 ==> (m1 = INT 0))" ]
    [ "!N. N below MIN ==> ~(POS N /\ H N)" ]
    [ "POS MIN" ]
    [ "H MIN" ]
    [ "POS N" ]
    [ "H N" ]
    [ "!N'. MAX below N' ==> ~~NEG(N minus (N' times MIN))" ]
    [ "~NEG(N minus (MAX times MIN))" ]

() : void

#expand ((MATCH_MP_IMP_TAC
#          (SPEC "neg (MAX times MIN)" PLUS_RIGHT_CANCELLATION)) THEN
#  (PURE_REWRITE_TAC [PLUS_INV_LEMMA;(SYM (SPEC_ALL MINUS_DEF))]));;
Definition MINUS_DEF autoloaded from theory `integer`.
MINUS_DEF = |- !M N. M minus N = M plus (neg N)

Theorem PLUS_INV_LEMMA autoloaded from theory `integer`.
PLUS_INV_LEMMA = 
|- !x. ((neg x) plus x = INT 0) /\ (x plus (neg x) = INT 0)

Theorem PLUS_RIGHT_CANCELLATION autoloaded from theory `integer`.
PLUS_RIGHT_CANCELLATION = |- !x y z. (y plus x = z plus x) ==> (y = z)

OK..
"N minus (MAX times MIN) = INT 0"
    [ "SUBGROUP((\N. T),$plus)H" ]
    [ "GROUP((\N. T),$plus)" ]
    [ "!x. H x ==> (\N. T)x" ]
    [ "GROUP(H,$plus)" ]
    [ "~(!m1. H m1 ==> (m1 = INT 0))" ]
    [ "!N. N below MIN ==> ~(POS N /\ H N)" ]
    [ "POS MIN" ]
    [ "H MIN" ]
    [ "POS N" ]
    [ "H N" ]
    [ "!N'. MAX below N' ==> ~~NEG(N minus (N' times MIN))" ]
    [ "~NEG(N minus (MAX times MIN))" ]

() : void

#expand (DISJ_CASES_TAC (CONJUNCT1
#   (SPEC "N minus (MAX times MIN)" TRICHOTOMY)));;
Theorem TRICHOTOMY autoloaded from theory `integer`.
TRICHOTOMY = 
|- !M.
    (POS M \/ NEG M \/ (M = INT 0)) /\
    ~(POS M /\ NEG M) /\
    ~(POS M /\ (M = INT 0)) /\
    ~(NEG M /\ (M = INT 0))

OK..
2 subgoals
"N minus (MAX times MIN) = INT 0"
    [ "SUBGROUP((\N. T),$plus)H" ]
    [ "GROUP((\N. T),$plus)" ]
    [ "!x. H x ==> (\N. T)x" ]
    [ "GROUP(H,$plus)" ]
    [ "~(!m1. H m1 ==> (m1 = INT 0))" ]
    [ "!N. N below MIN ==> ~(POS N /\ H N)" ]
    [ "POS MIN" ]
    [ "H MIN" ]
    [ "POS N" ]
    [ "H N" ]
    [ "!N'. MAX below N' ==> ~~NEG(N minus (N' times MIN))" ]
    [ "~NEG(N minus (MAX times MIN))" ]
    [ "NEG(N minus (MAX times MIN)) \/ (N minus (MAX times MIN) = INT 0)" ]

"N minus (MAX times MIN) = INT 0"
    [ "SUBGROUP((\N. T),$plus)H" ]
    [ "GROUP((\N. T),$plus)" ]
    [ "!x. H x ==> (\N. T)x" ]
    [ "GROUP(H,$plus)" ]
    [ "~(!m1. H m1 ==> (m1 = INT 0))" ]
    [ "!N. N below MIN ==> ~(POS N /\ H N)" ]
    [ "POS MIN" ]
    [ "H MIN" ]
    [ "POS N" ]
    [ "H N" ]
    [ "!N'. MAX below N' ==> ~~NEG(N minus (N' times MIN))" ]
    [ "~NEG(N minus (MAX times MIN))" ]
    [ "POS(N minus (MAX times MIN))" ]

() : void

#expand (SUPPOSE_TAC "(N minus (MAX times MIN)) below MIN");;
OK..
2 subgoals
"(N minus (MAX times MIN)) below MIN"
    [ "SUBGROUP((\N. T),$plus)H" ]
    [ "GROUP((\N. T),$plus)" ]
    [ "!x. H x ==> (\N. T)x" ]
    [ "GROUP(H,$plus)" ]
    [ "~(!m1. H m1 ==> (m1 = INT 0))" ]
    [ "!N. N below MIN ==> ~(POS N /\ H N)" ]
    [ "POS MIN" ]
    [ "H MIN" ]
    [ "POS N" ]
    [ "H N" ]
    [ "!N'. MAX below N' ==> ~~NEG(N minus (N' times MIN))" ]
    [ "~NEG(N minus (MAX times MIN))" ]
    [ "POS(N minus (MAX times MIN))" ]

"N minus (MAX times MIN) = INT 0"
    [ "SUBGROUP((\N. T),$plus)H" ]
    [ "GROUP((\N. T),$plus)" ]
    [ "!x. H x ==> (\N. T)x" ]
    [ "GROUP(H,$plus)" ]
    [ "~(!m1. H m1 ==> (m1 = INT 0))" ]
    [ "!N. N below MIN ==> ~(POS N /\ H N)" ]
    [ "POS MIN" ]
    [ "H MIN" ]
    [ "POS N" ]
    [ "H N" ]
    [ "!N'. MAX below N' ==> ~~NEG(N minus (N' times MIN))" ]
    [ "~NEG(N minus (MAX times MIN))" ]
    [ "POS(N minus (MAX times MIN))" ]
    [ "(N minus (MAX times MIN)) below MIN" ]

() : void

#expand (SUPPOSE_TAC "(H (N minus (MAX times MIN))):bool");;
OK..
2 subgoals
"H(N minus (MAX times MIN))"
    [ "SUBGROUP((\N. T),$plus)H" ]
    [ "GROUP((\N. T),$plus)" ]
    [ "!x. H x ==> (\N. T)x" ]
    [ "GROUP(H,$plus)" ]
    [ "~(!m1. H m1 ==> (m1 = INT 0))" ]
    [ "!N. N below MIN ==> ~(POS N /\ H N)" ]
    [ "POS MIN" ]
    [ "H MIN" ]
    [ "POS N" ]
    [ "H N" ]
    [ "!N'. MAX below N' ==> ~~NEG(N minus (N' times MIN))" ]
    [ "~NEG(N minus (MAX times MIN))" ]
    [ "POS(N minus (MAX times MIN))" ]
    [ "(N minus (MAX times MIN)) below MIN" ]

"N minus (MAX times MIN) = INT 0"
    [ "SUBGROUP((\N. T),$plus)H" ]
    [ "GROUP((\N. T),$plus)" ]
    [ "!x. H x ==> (\N. T)x" ]
    [ "GROUP(H,$plus)" ]
    [ "~(!m1. H m1 ==> (m1 = INT 0))" ]
    [ "!N. N below MIN ==> ~(POS N /\ H N)" ]
    [ "POS MIN" ]
    [ "H MIN" ]
    [ "POS N" ]
    [ "H N" ]
    [ "!N'. MAX below N' ==> ~~NEG(N minus (N' times MIN))" ]
    [ "~NEG(N minus (MAX times MIN))" ]
    [ "POS(N minus (MAX times MIN))" ]
    [ "(N minus (MAX times MIN)) below MIN" ]
    [ "H(N minus (MAX times MIN))" ]

() : void

#expand (RES_TAC THEN RES_TAC);;
OK..
goal proved
....... |- N minus (MAX times MIN) = INT 0

Previous subproof:
"H(N minus (MAX times MIN))"
    [ "SUBGROUP((\N. T),$plus)H" ]
    [ "GROUP((\N. T),$plus)" ]
    [ "!x. H x ==> (\N. T)x" ]
    [ "GROUP(H,$plus)" ]
    [ "~(!m1. H m1 ==> (m1 = INT 0))" ]
    [ "!N. N below MIN ==> ~(POS N /\ H N)" ]
    [ "POS MIN" ]
    [ "H MIN" ]
    [ "POS N" ]
    [ "H N" ]
    [ "!N'. MAX below N' ==> ~~NEG(N minus (N' times MIN))" ]
    [ "~NEG(N minus (MAX times MIN))" ]
    [ "POS(N minus (MAX times MIN))" ]
    [ "(N minus (MAX times MIN)) below MIN" ]

() : void

#expand (PURE_ONCE_REWRITE_TAC [MINUS_DEF]);;
OK..
"H(N plus (neg(MAX times MIN)))"
    [ "SUBGROUP((\N. T),$plus)H" ]
    [ "GROUP((\N. T),$plus)" ]
    [ "!x. H x ==> (\N. T)x" ]
    [ "GROUP(H,$plus)" ]
    [ "~(!m1. H m1 ==> (m1 = INT 0))" ]
    [ "!N. N below MIN ==> ~(POS N /\ H N)" ]
    [ "POS MIN" ]
    [ "H MIN" ]
    [ "POS N" ]
    [ "H N" ]
    [ "!N'. MAX below N' ==> ~~NEG(N minus (N' times MIN))" ]
    [ "~NEG(N minus (MAX times MIN))" ]
    [ "POS(N minus (MAX times MIN))" ]
    [ "(N minus (MAX times MIN)) below MIN" ]

() : void

#expand (GROUP_TAC [INT_SBGP_neg;INT_SBGP_TIMES_CLOSED]);;
OK..
goal proved
.... |- H(N plus (neg(MAX times MIN)))
.... |- H(N minus (MAX times MIN))
........ |- N minus (MAX times MIN) = INT 0

Previous subproof:
"(N minus (MAX times MIN)) below MIN"
    [ "SUBGROUP((\N. T),$plus)H" ]
    [ "GROUP((\N. T),$plus)" ]
    [ "!x. H x ==> (\N. T)x" ]
    [ "GROUP(H,$plus)" ]
    [ "~(!m1. H m1 ==> (m1 = INT 0))" ]
    [ "!N. N below MIN ==> ~(POS N /\ H N)" ]
    [ "POS MIN" ]
    [ "H MIN" ]
    [ "POS N" ]
    [ "H N" ]
    [ "!N'. MAX below N' ==> ~~NEG(N minus (N' times MIN))" ]
    [ "~NEG(N minus (MAX times MIN))" ]
    [ "POS(N minus (MAX times MIN))" ]

() : void

#expand (PURE_ONCE_REWRITE_TAC [BELOW_DEF]);;
Definition BELOW_DEF autoloaded from theory `integer`.
BELOW_DEF = |- !M N. M below N = POS(N minus M)

OK..
"POS(MIN minus (N minus (MAX times MIN)))"
    [ "SUBGROUP((\N. T),$plus)H" ]
    [ "GROUP((\N. T),$plus)" ]
    [ "!x. H x ==> (\N. T)x" ]
    [ "GROUP(H,$plus)" ]
    [ "~(!m1. H m1 ==> (m1 = INT 0))" ]
    [ "!N. N below MIN ==> ~(POS N /\ H N)" ]
    [ "POS MIN" ]
    [ "H MIN" ]
    [ "POS N" ]
    [ "H N" ]
    [ "!N'. MAX below N' ==> ~~NEG(N minus (N' times MIN))" ]
    [ "~NEG(N minus (MAX times MIN))" ]
    [ "POS(N minus (MAX times MIN))" ]

() : void

#expand ((NEW_SUBST1_TAC
#     (SYM (SPEC "MIN minus (N minus (MAX times MIN))"
#        PLUS_INV_INV_LEMMA))) THEN
#   (PURE_ONCE_REWRITE_TAC [(SYM (SPEC_ALL(NEG_DEF)))]));;
Definition NEG_DEF autoloaded from theory `integer`.
NEG_DEF = |- !M. NEG M = POS(neg M)

Theorem PLUS_INV_INV_LEMMA autoloaded from theory `integer`.
PLUS_INV_INV_LEMMA = |- !x. neg(neg x) = x

OK..
"NEG(neg(MIN minus (N minus (MAX times MIN))))"
    [ "SUBGROUP((\N. T),$plus)H" ]
    [ "GROUP((\N. T),$plus)" ]
    [ "!x. H x ==> (\N. T)x" ]
    [ "GROUP(H,$plus)" ]
    [ "~(!m1. H m1 ==> (m1 = INT 0))" ]
    [ "!N. N below MIN ==> ~(POS N /\ H N)" ]
    [ "POS MIN" ]
    [ "H MIN" ]
    [ "POS N" ]
    [ "H N" ]
    [ "!N'. MAX below N' ==> ~~NEG(N minus (N' times MIN))" ]
    [ "~NEG(N minus (MAX times MIN))" ]
    [ "POS(N minus (MAX times MIN))" ]

() : void

#expand (PURE_REWRITE_TAC
#    [MINUS_DEF;
#     (SYM (SPEC_ALL (PLUS_DIST_INV_LEMMA)));
#     PLUS_INV_INV_LEMMA]);;
Theorem PLUS_DIST_INV_LEMMA autoloaded from theory `integer`.
PLUS_DIST_INV_LEMMA = |- !x y. (neg x) plus (neg y) = neg(y plus x)

OK..
"NEG((N plus (neg(MAX times MIN))) plus (neg MIN))"
    [ "SUBGROUP((\N. T),$plus)H" ]
    [ "GROUP((\N. T),$plus)" ]
    [ "!x. H x ==> (\N. T)x" ]
    [ "GROUP(H,$plus)" ]
    [ "~(!m1. H m1 ==> (m1 = INT 0))" ]
    [ "!N. N below MIN ==> ~(POS N /\ H N)" ]
    [ "POS MIN" ]
    [ "H MIN" ]
    [ "POS N" ]
    [ "H N" ]
    [ "!N'. MAX below N' ==> ~~NEG(N minus (N' times MIN))" ]
    [ "~NEG(N minus (MAX times MIN))" ]
    [ "POS(N minus (MAX times MIN))" ]

() : void

#expand ((INT_RIGHT_ASSOC_TAC
#     "(N plus (neg (MAX times MIN))) plus (neg MIN)") THEN
#  (PURE_REWRITE_TAC
#     [(SYM neg_PLUS_DISTRIB);(SYM (SPEC_ALL MINUS_DEF))]));;
Theorem neg_PLUS_DISTRIB autoloaded from theory `integer`.
neg_PLUS_DISTRIB = |- neg(M plus N) = (neg M) plus (neg N)

OK..
"NEG(N minus ((MAX times MIN) plus MIN))"
    [ "SUBGROUP((\N. T),$plus)H" ]
    [ "GROUP((\N. T),$plus)" ]
    [ "!x. H x ==> (\N. T)x" ]
    [ "GROUP(H,$plus)" ]
    [ "~(!m1. H m1 ==> (m1 = INT 0))" ]
    [ "!N. N below MIN ==> ~(POS N /\ H N)" ]
    [ "POS MIN" ]
    [ "H MIN" ]
    [ "POS N" ]
    [ "H N" ]
    [ "!N'. MAX below N' ==> ~~NEG(N minus (N' times MIN))" ]
    [ "~NEG(N minus (MAX times MIN))" ]
    [ "POS(N minus (MAX times MIN))" ]

() : void

#expand (PURE_ONCE_REWRITE_TAC
#    [(PURE_ONCE_REWRITE_RULE [TIMES_IDENTITY] (SYM
#      (SPECL ["MAX:integer";"INT 1";"MIN:integer"]
#        RIGHT_PLUS_DISTRIB)))]);;
OK..
"NEG(N minus ((MAX plus (INT 1)) times MIN))"
    [ "SUBGROUP((\N. T),$plus)H" ]
    [ "GROUP((\N. T),$plus)" ]
    [ "!x. H x ==> (\N. T)x" ]
    [ "GROUP(H,$plus)" ]
    [ "~(!m1. H m1 ==> (m1 = INT 0))" ]
    [ "!N. N below MIN ==> ~(POS N /\ H N)" ]
    [ "POS MIN" ]
    [ "H MIN" ]
    [ "POS N" ]
    [ "H N" ]
    [ "!N'. MAX below N' ==> ~~NEG(N minus (N' times MIN))" ]
    [ "~NEG(N minus (MAX times MIN))" ]
    [ "POS(N minus (MAX times MIN))" ]

() : void

#expand (MATCH_MP_IMP_TAC (ONCE_REWRITE_RULE []
#    (ASSUME "!N'.MAX below N' ==>~~NEG (N minus (N' times MIN))")));;
OK..
"MAX below (MAX plus (INT 1))"
    [ "SUBGROUP((\N. T),$plus)H" ]
    [ "GROUP((\N. T),$plus)" ]
    [ "!x. H x ==> (\N. T)x" ]
    [ "GROUP(H,$plus)" ]
    [ "~(!m1. H m1 ==> (m1 = INT 0))" ]
    [ "!N. N below MIN ==> ~(POS N /\ H N)" ]
    [ "POS MIN" ]
    [ "H MIN" ]
    [ "POS N" ]
    [ "H N" ]
    [ "!N'. MAX below N' ==> ~~NEG(N minus (N' times MIN))" ]
    [ "~NEG(N minus (MAX times MIN))" ]
    [ "POS(N minus (MAX times MIN))" ]

() : void

#expand ((SUBST_MATCH_TAC
#    (PURE_ONCE_REWRITE_RULE [COMM_PLUS]
#      (SPECL ["A:integer";"B:integer";"neg MAX"]
#        PLUS_BELOW_TRANSL))) THEN
#   (PURE_REWRITE_TAC
#       [(SYM (SPEC_ALL PLUS_GROUP_ASSOC));
#        PLUS_INV_LEMMA;
#        (SYM (SPEC_ALL NUM_LESS_IS_INT_BELOW));
#	PLUS_ID_LEMMA]));;
Theorem PLUS_ID_LEMMA autoloaded from theory `integer`.
PLUS_ID_LEMMA = 
|- (!x. (INT 0) plus x = x) /\
   (!x. x plus (INT 0) = x) /\
   (!x. ?y. y plus x = INT 0)

Theorem NUM_LESS_IS_INT_BELOW autoloaded from theory `integer`.
NUM_LESS_IS_INT_BELOW = |- !m n. m < n = (INT m) below (INT n)

Theorem PLUS_GROUP_ASSOC autoloaded from theory `integer`.
PLUS_GROUP_ASSOC = |- !x y z. (x plus y) plus z = x plus (y plus z)

Theorem PLUS_BELOW_TRANSL autoloaded from theory `integer`.
PLUS_BELOW_TRANSL = |- !M N P. M below N = (M plus P) below (N plus P)

Theorem COMM_PLUS autoloaded from theory `integer`.
COMM_PLUS = |- !M N. M plus N = N plus M

OK..
"0 < 1"
    [ "SUBGROUP((\N. T),$plus)H" ]
    [ "GROUP((\N. T),$plus)" ]
    [ "!x. H x ==> (\N. T)x" ]
    [ "GROUP(H,$plus)" ]
    [ "~(!m1. H m1 ==> (m1 = INT 0))" ]
    [ "!N. N below MIN ==> ~(POS N /\ H N)" ]
    [ "POS MIN" ]
    [ "H MIN" ]
    [ "POS N" ]
    [ "H N" ]
    [ "!N'. MAX below N' ==> ~~NEG(N minus (N' times MIN))" ]
    [ "~NEG(N minus (MAX times MIN))" ]
    [ "POS(N minus (MAX times MIN))" ]

() : void

#expand ((CONV_TAC (DEPTH_CONV num_CONV)) THEN
#  (ACCEPT_TAC (theorem `prim_rec` `LESS_0_0`)));;
OK..
goal proved
|- 0 < 1
|- MAX below (MAX plus (INT 1))
. |- NEG(N minus ((MAX plus (INT 1)) times MIN))
. |- NEG(N minus ((MAX times MIN) plus MIN))
. |- NEG((N plus (neg(MAX times MIN))) plus (neg MIN))
. |- NEG(neg(MIN minus (N minus (MAX times MIN))))
. |- POS(MIN minus (N minus (MAX times MIN)))
. |- (N minus (MAX times MIN)) below MIN
........ |- N minus (MAX times MIN) = INT 0

Previous subproof:
"N minus (MAX times MIN) = INT 0"
    [ "SUBGROUP((\N. T),$plus)H" ]
    [ "GROUP((\N. T),$plus)" ]
    [ "!x. H x ==> (\N. T)x" ]
    [ "GROUP(H,$plus)" ]
    [ "~(!m1. H m1 ==> (m1 = INT 0))" ]
    [ "!N. N below MIN ==> ~(POS N /\ H N)" ]
    [ "POS MIN" ]
    [ "H MIN" ]
    [ "POS N" ]
    [ "H N" ]
    [ "!N'. MAX below N' ==> ~~NEG(N minus (N' times MIN))" ]
    [ "~NEG(N minus (MAX times MIN))" ]
    [ "NEG(N minus (MAX times MIN)) \/ (N minus (MAX times MIN) = INT 0)" ]

() : void

#expand ((POP_ASSUM DISJ_CASES_TAC) THENL
#    [RES_TAC;(FIRST_ASSUM ACCEPT_TAC)]);;
OK..
goal proved
.. |- N minus (MAX times MIN) = INT 0
........ |- N minus (MAX times MIN) = INT 0
........ |- N = MAX times MIN
........ |- ?p. N = p times MIN

Previous subproof:
2 subgoals
"?UB. !N'. UB below N' ==> ~~NEG(N minus (N' times MIN))"
    [ "SUBGROUP((\N. T),$plus)H" ]
    [ "GROUP((\N. T),$plus)" ]
    [ "!x. H x ==> (\N. T)x" ]
    [ "GROUP(H,$plus)" ]
    [ "~(!m1. H m1 ==> (m1 = INT 0))" ]
    [ "!N. N below MIN ==> ~(POS N /\ H N)" ]
    [ "POS MIN" ]
    [ "H MIN" ]
    [ "POS N" ]
    [ "H N" ]
    [ "~NEG(N minus (M times MIN))" ]

"?M. ~NEG(N minus (M times MIN))"
    [ "SUBGROUP((\N. T),$plus)H" ]
    [ "GROUP((\N. T),$plus)" ]
    [ "!x. H x ==> (\N. T)x" ]
    [ "GROUP(H,$plus)" ]
    [ "~(!m1. H m1 ==> (m1 = INT 0))" ]
    [ "!N. N below MIN ==> ~(POS N /\ H N)" ]
    [ "POS MIN" ]
    [ "H MIN" ]
    [ "POS N" ]
    [ "H N" ]

() : void

#expand ((EXISTS_TAC "INT 0") THEN
#  (PURE_REWRITE_TAC
#    [MINUS_DEF;TIMES_ZERO;PLUS_INV_ID_LEMMA;PLUS_ID_LEMMA]));;
Theorem PLUS_INV_ID_LEMMA autoloaded from theory `integer`.
PLUS_INV_ID_LEMMA = |- neg(INT 0) = INT 0

OK..
"~NEG N"
    [ "SUBGROUP((\N. T),$plus)H" ]
    [ "GROUP((\N. T),$plus)" ]
    [ "!x. H x ==> (\N. T)x" ]
    [ "GROUP(H,$plus)" ]
    [ "~(!m1. H m1 ==> (m1 = INT 0))" ]
    [ "!N. N below MIN ==> ~(POS N /\ H N)" ]
    [ "POS MIN" ]
    [ "H MIN" ]
    [ "POS N" ]
    [ "H N" ]

() : void

#expand (ACCEPT_TAC (REWRITE_RULE [(ASSUME "POS N")]
#    (CONJUNCT1 (CONJUNCT2 (SPEC "N:integer" TRICHOTOMY)))));;
OK..
goal proved
. |- ~NEG N
. |- ?M. ~NEG(N minus (M times MIN))

Previous subproof:
"?UB. !N'. UB below N' ==> ~~NEG(N minus (N' times MIN))"
    [ "SUBGROUP((\N. T),$plus)H" ]
    [ "GROUP((\N. T),$plus)" ]
    [ "!x. H x ==> (\N. T)x" ]
    [ "GROUP(H,$plus)" ]
    [ "~(!m1. H m1 ==> (m1 = INT 0))" ]
    [ "!N. N below MIN ==> ~(POS N /\ H N)" ]
    [ "POS MIN" ]
    [ "H MIN" ]
    [ "POS N" ]
    [ "H N" ]
    [ "~NEG(N minus (M times MIN))" ]

() : void

#expand (EXISTS_TAC "N:integer");;
OK..
"!N'. N below N' ==> ~~NEG(N minus (N' times MIN))"
    [ "SUBGROUP((\N. T),$plus)H" ]
    [ "GROUP((\N. T),$plus)" ]
    [ "!x. H x ==> (\N. T)x" ]
    [ "GROUP(H,$plus)" ]
    [ "~(!m1. H m1 ==> (m1 = INT 0))" ]
    [ "!N. N below MIN ==> ~(POS N /\ H N)" ]
    [ "POS MIN" ]
    [ "H MIN" ]
    [ "POS N" ]
    [ "H N" ]
    [ "~NEG(N minus (M times MIN))" ]

() : void

#expand ((REWRITE_TAC
#     [NEG_DEF;
#      MINUS_DEF;
#      (SYM (SPEC_ALL PLUS_DIST_INV_LEMMA));
#      PLUS_INV_INV_LEMMA]) THEN
#  (PURE_REWRITE_TAC[(SYM (SPEC_ALL MINUS_DEF));
#      (SYM (SPEC_ALL BELOW_DEF))]));;
OK..
"!N'. N below N' ==> N below (N' times MIN)"
    [ "SUBGROUP((\N. T),$plus)H" ]
    [ "GROUP((\N. T),$plus)" ]
    [ "!x. H x ==> (\N. T)x" ]
    [ "GROUP(H,$plus)" ]
    [ "~(!m1. H m1 ==> (m1 = INT 0))" ]
    [ "!N. N below MIN ==> ~(POS N /\ H N)" ]
    [ "POS MIN" ]
    [ "H MIN" ]
    [ "POS N" ]
    [ "H N" ]
    [ "~NEG(N minus (M times MIN))" ]

() : void

#expand ((STRIP_ASSUME_TAC
#    (PURE_ONCE_REWRITE_RULE [POS_DEF] (ASSUME "POS MIN"))) THEN
#  (PURE_ONCE_ASM_REWRITE_TAC[]));;
Definition POS_DEF autoloaded from theory `integer`.
POS_DEF = |- !M. POS M = (?n. M = INT(SUC n))

OK..
"!N'. N below N' ==> N below (N' times (INT(SUC n)))"
    [ "SUBGROUP((\N. T),$plus)H" ]
    [ "GROUP((\N. T),$plus)" ]
    [ "!x. H x ==> (\N. T)x" ]
    [ "GROUP(H,$plus)" ]
    [ "~(!m1. H m1 ==> (m1 = INT 0))" ]
    [ "!N. N below MIN ==> ~(POS N /\ H N)" ]
    [ "POS MIN" ]
    [ "H MIN" ]
    [ "POS N" ]
    [ "H N" ]
    [ "~NEG(N minus (M times MIN))" ]
    [ "MIN = INT(SUC n)" ]

() : void

#expand ((DISJ_CASES_TAC (SPEC "n:num" LESS_0_CASES)) THENL
#    [(POP_ASSUM \thm. (ASM_REWRITE_TAC
#        [(SYM thm);(SYM (num_CONV "1"));TIMES_IDENTITY]));
#     ALL_TAC]);;
Theorem LESS_0_CASES autoloaded from theory `arithmetic`.
LESS_0_CASES = |- !m. (0 = m) \/ 0 < m

OK..
"!N'. N below N' ==> N below (N' times (INT(SUC n)))"
    [ "SUBGROUP((\N. T),$plus)H" ]
    [ "GROUP((\N. T),$plus)" ]
    [ "!x. H x ==> (\N. T)x" ]
    [ "GROUP(H,$plus)" ]
    [ "~(!m1. H m1 ==> (m1 = INT 0))" ]
    [ "!N. N below MIN ==> ~(POS N /\ H N)" ]
    [ "POS MIN" ]
    [ "H MIN" ]
    [ "POS N" ]
    [ "H N" ]
    [ "~NEG(N minus (M times MIN))" ]
    [ "MIN = INT(SUC n)" ]
    [ "0 < n" ]

() : void

#expand ((REPEAT STRIP_TAC) THEN
#  (MP_IMP_TAC
#    (SPECL ["N:integer";"N':integer";"N' times (INT(SUC n))"]
#     TRANSIT)) THEN
#  (ASM_REWRITE_TAC []));;
Theorem TRANSIT autoloaded from theory `integer`.
TRANSIT = |- !M N P. M below N /\ N below P ==> M below P

OK..
"N' below (N' times (INT(SUC n)))"
    [ "SUBGROUP((\N. T),$plus)H" ]
    [ "GROUP((\N. T),$plus)" ]
    [ "!x. H x ==> (\N. T)x" ]
    [ "GROUP(H,$plus)" ]
    [ "~(!m1. H m1 ==> (m1 = INT 0))" ]
    [ "!N. N below MIN ==> ~(POS N /\ H N)" ]
    [ "POS MIN" ]
    [ "H MIN" ]
    [ "POS N" ]
    [ "H N" ]
    [ "~NEG(N minus (M times MIN))" ]
    [ "MIN = INT(SUC n)" ]
    [ "0 < n" ]
    [ "N below N'" ]

() : void

#expand ((PURE_REWRITE_TAC
#     [ADD1; (SYM (SPEC_ALL NUM_ADD_IS_INT_ADD));
#      LEFT_PLUS_DISTRIB; TIMES_IDENTITY]) THEN
#  (NEW_SUBST1_TAC
#    (SPECL ["N':integer";"(N' times (INT n)) plus N'";"neg N'"]
#      PLUS_BELOW_TRANSL)) THEN
#  (PURE_REWRITE_TAC [PLUS_GROUP_ASSOC;PLUS_INV_LEMMA;PLUS_ID_LEMMA]));;
Theorem LEFT_PLUS_DISTRIB autoloaded from theory `integer`.
LEFT_PLUS_DISTRIB = 
|- !M N P. M times (N plus P) = (M times N) plus (M times P)

OK..
"(INT 0) below (N' times (INT n))"
    [ "SUBGROUP((\N. T),$plus)H" ]
    [ "GROUP((\N. T),$plus)" ]
    [ "!x. H x ==> (\N. T)x" ]
    [ "GROUP(H,$plus)" ]
    [ "~(!m1. H m1 ==> (m1 = INT 0))" ]
    [ "!N. N below MIN ==> ~(POS N /\ H N)" ]
    [ "POS MIN" ]
    [ "H MIN" ]
    [ "POS N" ]
    [ "H N" ]
    [ "~NEG(N minus (M times MIN))" ]
    [ "MIN = INT(SUC n)" ]
    [ "0 < n" ]
    [ "N below N'" ]

() : void

#expand ((NEW_SUBST1_TAC
#    (SYM (CONJUNCT1 (SPEC "N':integer" TIMES_ZERO)))) THEN
#  (NEW_SUBST1_TAC
#    (SYM (UNDISCH (SPECL ["N':integer"; "INT 0"; "INT n"]
#      POS_MULT_PRES_BELOW)))));;
Theorem POS_MULT_PRES_BELOW autoloaded from theory `integer`.
POS_MULT_PRES_BELOW = 
|- !M N P. POS M ==> (N below P = (M times N) below (M times P))

OK..
2 subgoals
"POS N'"
    [ "SUBGROUP((\N. T),$plus)H" ]
    [ "GROUP((\N. T),$plus)" ]
    [ "!x. H x ==> (\N. T)x" ]
    [ "GROUP(H,$plus)" ]
    [ "~(!m1. H m1 ==> (m1 = INT 0))" ]
    [ "!N. N below MIN ==> ~(POS N /\ H N)" ]
    [ "POS MIN" ]
    [ "H MIN" ]
    [ "POS N" ]
    [ "H N" ]
    [ "~NEG(N minus (M times MIN))" ]
    [ "MIN = INT(SUC n)" ]
    [ "0 < n" ]
    [ "N below N'" ]

"(INT 0) below (INT n)"
    [ "SUBGROUP((\N. T),$plus)H" ]
    [ "GROUP((\N. T),$plus)" ]
    [ "!x. H x ==> (\N. T)x" ]
    [ "GROUP(H,$plus)" ]
    [ "~(!m1. H m1 ==> (m1 = INT 0))" ]
    [ "!N. N below MIN ==> ~(POS N /\ H N)" ]
    [ "POS MIN" ]
    [ "H MIN" ]
    [ "POS N" ]
    [ "H N" ]
    [ "~NEG(N minus (M times MIN))" ]
    [ "MIN = INT(SUC n)" ]
    [ "0 < n" ]
    [ "N below N'" ]
    [ "POS N'" ]

() : void

#expand (ASM_REWRITE_TAC [(SYM (SPEC_ALL (NUM_LESS_IS_INT_BELOW)))]);;
OK..
goal proved
. |- (INT 0) below (INT n)

Previous subproof:
"POS N'"
    [ "SUBGROUP((\N. T),$plus)H" ]
    [ "GROUP((\N. T),$plus)" ]
    [ "!x. H x ==> (\N. T)x" ]
    [ "GROUP(H,$plus)" ]
    [ "~(!m1. H m1 ==> (m1 = INT 0))" ]
    [ "!N. N below MIN ==> ~(POS N /\ H N)" ]
    [ "POS MIN" ]
    [ "H MIN" ]
    [ "POS N" ]
    [ "H N" ]
    [ "~NEG(N minus (M times MIN))" ]
    [ "MIN = INT(SUC n)" ]
    [ "0 < n" ]
    [ "N below N'" ]

() : void

#expand ((PURE_ONCE_REWRITE_TAC [POS_IS_ZERO_BELOW]) THEN
#  (MP_IMP_TAC (SPECL ["INT 0";"N:integer";"N':integer"] TRANSIT)) THEN
#  (ASM_REWRITE_TAC[(SYM (SPEC_ALL POS_IS_ZERO_BELOW))]));;
Theorem POS_IS_ZERO_BELOW autoloaded from theory `integer`.
POS_IS_ZERO_BELOW = |- !N. POS N = (INT 0) below N

OK..
goal proved
.. |- POS N'
... |- (INT 0) below (N' times (INT n))
... |- N' below (N' times (INT(SUC n)))
.. |- !N'. N below N' ==> N below (N' times (INT(SUC n)))
. |- !N'. N below N' ==> N below (N' times (INT(SUC n)))
.. |- !N'. N below N' ==> N below (N' times MIN)
.. |- !N'. N below N' ==> ~~NEG(N minus (N' times MIN))
.. |- ?UB. !N'. UB below N' ==> ~~NEG(N minus (N' times MIN))
........ |- ?p. N = p times MIN
...... |- !N. POS N ==> H N ==> (?p. N = p times MIN)

Previous subproof:
2 subgoals
"H(INT 0) ==> (?p. INT 0 = p times MIN)"
    [ "SUBGROUP((\N. T),$plus)H" ]
    [ "GROUP((\N. T),$plus)" ]
    [ "!x. H x ==> (\N. T)x" ]
    [ "GROUP(H,$plus)" ]
    [ "~(!m1. H m1 ==> (m1 = INT 0))" ]
    [ "!N. N below MIN ==> ~(POS N /\ H N)" ]
    [ "POS MIN" ]
    [ "H MIN" ]

"!N. NEG N ==> H N ==> (?p. N = p times MIN)"
    [ "SUBGROUP((\N. T),$plus)H" ]
    [ "GROUP((\N. T),$plus)" ]
    [ "!x. H x ==> (\N. T)x" ]
    [ "GROUP(H,$plus)" ]
    [ "~(!m1. H m1 ==> (m1 = INT 0))" ]
    [ "!N. N below MIN ==> ~(POS N /\ H N)" ]
    [ "POS MIN" ]
    [ "H MIN" ]
    [ "!N. POS N ==> H N ==> (?p. N = p times MIN)" ]

() : void

#expand ((PURE_ONCE_REWRITE_TAC [NEG_DEF]) THEN
#  (REPEAT STRIP_TAC) THEN
#  (NEW_SUBST1_TAC (SYM (SPEC "N:integer" PLUS_INV_INV_LEMMA))));;
OK..
"?p. neg(neg N) = p times MIN"
    [ "SUBGROUP((\N. T),$plus)H" ]
    [ "GROUP((\N. T),$plus)" ]
    [ "!x. H x ==> (\N. T)x" ]
    [ "GROUP(H,$plus)" ]
    [ "~(!m1. H m1 ==> (m1 = INT 0))" ]
    [ "!N. N below MIN ==> ~(POS N /\ H N)" ]
    [ "POS MIN" ]
    [ "H MIN" ]
    [ "!N. POS N ==> H N ==> (?p. N = p times MIN)" ]
    [ "POS(neg N)" ]
    [ "H N" ]

() : void

#expand (STRIP_ASSUME_TAC (MP
#    (UNDISCH (SPEC "neg N"
#      (ASSUME "!N. POS N ==> H N ==> (?p. N = p times MIN)")))
#    (UNDISCH (SPEC "N:integer" (UNDISCH
#      (SPEC "H:integer -> bool" INT_SBGP_neg))))));;
OK..
"?p. neg(neg N) = p times MIN"
    [ "SUBGROUP((\N. T),$plus)H" ]
    [ "GROUP((\N. T),$plus)" ]
    [ "!x. H x ==> (\N. T)x" ]
    [ "GROUP(H,$plus)" ]
    [ "~(!m1. H m1 ==> (m1 = INT 0))" ]
    [ "!N. N below MIN ==> ~(POS N /\ H N)" ]
    [ "POS MIN" ]
    [ "H MIN" ]
    [ "!N. POS N ==> H N ==> (?p. N = p times MIN)" ]
    [ "POS(neg N)" ]
    [ "H N" ]
    [ "neg N = p times MIN" ]

() : void

#expand ((EXISTS_TAC "neg p") THEN (ASM_REWRITE_TAC [TIMES_neg]));;
OK..
goal proved
. |- ?p. neg(neg N) = p times MIN
.... |- ?p. neg(neg N) = p times MIN
.. |- !N. NEG N ==> H N ==> (?p. N = p times MIN)

Previous subproof:
"H(INT 0) ==> (?p. INT 0 = p times MIN)"
    [ "SUBGROUP((\N. T),$plus)H" ]
    [ "GROUP((\N. T),$plus)" ]
    [ "!x. H x ==> (\N. T)x" ]
    [ "GROUP(H,$plus)" ]
    [ "~(!m1. H m1 ==> (m1 = INT 0))" ]
    [ "!N. N below MIN ==> ~(POS N /\ H N)" ]
    [ "POS MIN" ]
    [ "H MIN" ]

() : void

#expand (DISCH_TAC THEN (EXISTS_TAC "INT 0") THEN
#  (REWRITE_TAC [TIMES_ZERO]));;
OK..
goal proved
|- H(INT 0) ==> (?p. INT 0 = p times MIN)
...... |- H m ==> (?p. m = p times MIN)

Previous subproof:
"(?p. m = p times MIN) ==> H m"
    [ "SUBGROUP((\N. T),$plus)H" ]
    [ "GROUP((\N. T),$plus)" ]
    [ "!x. H x ==> (\N. T)x" ]
    [ "GROUP(H,$plus)" ]
    [ "~(!m1. H m1 ==> (m1 = INT 0))" ]
    [ "!N. N below MIN ==> ~(POS N /\ H N)" ]
    [ "POS MIN" ]
    [ "H MIN" ]

() : void

#expand (STRIP_TAC THEN (ASM_REWRITE_TAC []) THEN
#  (NEW_MATCH_ACCEPT_TAC
#    (UNDISCH (SPEC_ALL (UNDISCH (SPEC_ALL INT_SBGP_TIMES_CLOSED))))));;
OK..
goal proved
.. |- (?p. m = p times MIN) ==> H m
...... |- H = (\m. ?p. m = p times MIN)
....... |- H = (\m. ?p. m = p times (INT n))
....... |- ?n. H = (\m. ?p. m = p times (INT n))
....... |- ?n. H = (\m. ?p. m = p times (INT n))

Previous subproof:
"?n. INT n = MIN"
    [ "SUBGROUP((\N. T),$plus)H" ]
    [ "GROUP((\N. T),$plus)" ]
    [ "!x. H x ==> (\N. T)x" ]
    [ "GROUP(H,$plus)" ]
    [ "~(!m1. H m1 ==> (m1 = INT 0))" ]
    [ "!N. N below MIN ==> ~(POS N /\ H N)" ]
    [ "POS MIN" ]
    [ "H MIN" ]

() : void

#expand (STRIP_ASSUME_TAC
#    (PURE_ONCE_REWRITE_RULE [POS_DEF] (ASSUME "POS MIN")));;
OK..
"?n. INT n = MIN"
    [ "SUBGROUP((\N. T),$plus)H" ]
    [ "GROUP((\N. T),$plus)" ]
    [ "!x. H x ==> (\N. T)x" ]
    [ "GROUP(H,$plus)" ]
    [ "~(!m1. H m1 ==> (m1 = INT 0))" ]
    [ "!N. N below MIN ==> ~(POS N /\ H N)" ]
    [ "POS MIN" ]
    [ "H MIN" ]
    [ "MIN = INT(SUC n)" ]

() : void

#expand ((EXISTS_TAC "SUC n") THEN (ASM_REWRITE_TAC []));;
OK..
goal proved
. |- ?n. INT n = MIN
. |- ?n. INT n = MIN
...... |- ?n. H = (\m. ?p. m = p times (INT n))
..... |- ?n. H = (\m. ?p. m = p times (INT n))

Previous subproof:
2 subgoals
"?LB. !N. N below LB ==> ~(POS N /\ H N)"
    [ "SUBGROUP((\N. T),$plus)H" ]
    [ "GROUP((\N. T),$plus)" ]
    [ "!x. H x ==> (\N. T)x" ]
    [ "GROUP(H,$plus)" ]
    [ "~(!m1. H m1 ==> (m1 = INT 0))" ]
    [ "POS M /\ H M" ]

"?M. POS M /\ H M"
    [ "SUBGROUP((\N. T),$plus)H" ]
    [ "GROUP((\N. T),$plus)" ]
    [ "!x. H x ==> (\N. T)x" ]
    [ "GROUP(H,$plus)" ]
    [ "~(!m1. H m1 ==> (m1 = INT 0))" ]

() : void

#expand (POP_ASSUM \thm. STRIP_ASSUME_TAC
#    (REWRITE_RULE [IMP_DISJ_THM;DE_MORGAN_THM]
#     (CONV_RULE NOT_FORALL_CONV thm)));;
Theorem IMP_DISJ_THM autoloaded from theory `arithmetic`.
IMP_DISJ_THM = |- !t1 t2. t1 ==> t2 = ~t1 \/ t2

OK..
"?M. POS M /\ H M"
    [ "SUBGROUP((\N. T),$plus)H" ]
    [ "GROUP((\N. T),$plus)" ]
    [ "!x. H x ==> (\N. T)x" ]
    [ "GROUP(H,$plus)" ]
    [ "H m1" ]
    [ "~(m1 = INT 0)" ]

() : void

#expand ((DISJ_CASES_TAC
#    (CONJUNCT1 (SPEC "m1:integer" TRICHOTOMY))) THENL
#  [((EXISTS_TAC "m1:integer") THEN (ASM_REWRITE_TAC []));
#   ((POP_ASSUM DISJ_CASES_TAC) THENL
#    [ALL_TAC; RES_TAC])]);;
OK..
"?M. POS M /\ H M"
    [ "SUBGROUP((\N. T),$plus)H" ]
    [ "GROUP((\N. T),$plus)" ]
    [ "!x. H x ==> (\N. T)x" ]
    [ "GROUP(H,$plus)" ]
    [ "H m1" ]
    [ "~(m1 = INT 0)" ]
    [ "NEG m1" ]

() : void

#expand ((EXISTS_TAC "neg m1") THEN
#  (ASM_REWRITE_TAC
#    [(SYM (SPEC_ALL NEG_DEF));
#     (UNDISCH (SPEC "m1:integer"
#      (UNDISCH (SPEC_ALL INT_SBGP_neg))))]));;
OK..
goal proved
... |- ?M. POS M /\ H M
... |- ?M. POS M /\ H M
.. |- ?M. POS M /\ H M

Previous subproof:
"?LB. !N. N below LB ==> ~(POS N /\ H N)"
    [ "SUBGROUP((\N. T),$plus)H" ]
    [ "GROUP((\N. T),$plus)" ]
    [ "!x. H x ==> (\N. T)x" ]
    [ "GROUP(H,$plus)" ]
    [ "~(!m1. H m1 ==> (m1 = INT 0))" ]
    [ "POS M /\ H M" ]

() : void

#expand (EXISTS_TAC "INT 0");;
OK..
"!N. N below (INT 0) ==> ~(POS N /\ H N)"
    [ "SUBGROUP((\N. T),$plus)H" ]
    [ "GROUP((\N. T),$plus)" ]
    [ "!x. H x ==> (\N. T)x" ]
    [ "GROUP(H,$plus)" ]
    [ "~(!m1. H m1 ==> (m1 = INT 0))" ]
    [ "POS M /\ H M" ]

() : void

#expand (PURE_ONCE_REWRITE_TAC [(SYM (SPEC_ALL NEG_IS_BELOW_ZERO))]);;
Theorem NEG_IS_BELOW_ZERO autoloaded from theory `integer`.
NEG_IS_BELOW_ZERO = |- !N. NEG N = N below (INT 0)

OK..
"!N. NEG N ==> ~(POS N /\ H N)"
    [ "SUBGROUP((\N. T),$plus)H" ]
    [ "GROUP((\N. T),$plus)" ]
    [ "!x. H x ==> (\N. T)x" ]
    [ "GROUP(H,$plus)" ]
    [ "~(!m1. H m1 ==> (m1 = INT 0))" ]
    [ "POS M /\ H M" ]

() : void

#expand (GEN_TAC THEN DISCH_TAC THEN
#  (REWRITE_TAC
#    [(REWRITE_RULE[(ASSUME "NEG N")]
#    (CONJUNCT1 (CONJUNCT2 (SPEC "N:integer" TRICHOTOMY))))]));;
OK..
goal proved
|- !N. NEG N ==> ~(POS N /\ H N)
|- !N. N below (INT 0) ==> ~(POS N /\ H N)
|- ?LB. !N. N below LB ==> ~(POS N /\ H N)
.... |- ?n. H = (\m. ?p. m = p times (INT n))
... |- ?n. H = int_mult_set(INT n)
|- !H. SUBGROUP((\N. T),$plus)H ==> (?n. H = int_mult_set(INT n))

Previous subproof:
goal proved
() : void

#loadt `temp`;;

INT_SBGP_CYCLIC = 
|- !H. SUBGROUP((\N. T),$plus)H ==> (?n. H = int_mult_set(INT n))


File temp loaded
() : void

#quit();;
faulkner% 