\DOC REW_DEPTH_CONV

\TYPE {REW_DEPTH_CONV : (conv -> conv)}

\SYNOPSIS
Applies a conversion top-down to all subterms, retraversing changed ones.
For use in rewriting.

\KEYWORDS
conversional.

\DESCRIBE
{REW_DEPTH_CONV c tm} repeatedly applies the conversion {c} to all the subterms
of the term {tm}, including the term {tm} itself. The supplied conversion {c}
is applied to the subterms of {tm} in top-down order and is applied repeatedly
(zero or more times, as is done by {REPEATC}) at each subterm until it fails.
If a subterm {t} is changed (up to alpha-equivalence) by virtue of the
application of {c} to its own subterms, then the term into which {t} is
transformed is retraversed by applying {REW_DEPTH_CONV c} to it.

{REW_DEPTH_CONV} is a special version of {TOP_DEPTH_CONV} for use by the
rewriting conversions, rules and tactics. It differs from {TOP_DEPTH_CONV} as
follows: If converting an abstraction fails due to the presence of the bound
variable in the hypotheses of the theorem generated by converting the body,
{REW_DEPTH_CONV} retries the conversion having renamed the bound variable of
the abstraction. If successful the renaming is reversed.

\FAILURE
{REW_DEPTH_CONV c tm} never fails but can diverge.

\EXAMPLE
The following example illustrates the difference between the functions
{REW_DEPTH_CONV} and {TOP_DEPTH_CONV}. It is not intended to illustrate the
full range of behaviour of the former. Both {REW_DEPTH_CONV} and
{TOP_DEPTH_CONV} successfully apply the theorem {ADD_0} inside an abstraction:
{
   #REW_DEPTH_CONV (REWR_CONV ADD_0) "\n. n + 0";;
   |- (\n. n + 0) = (\n. n)

   #TOP_DEPTH_CONV (REWR_CONV ADD_0) "\n. n + 0";;
   |- (\n. n + 0) = (\n. n)
}
\noindent However, if a hypothesis containing a free occurrence of the bound
variable is added to the rewrite rule, it interferes with the operation of
{TOP_DEPTH_CONV} but not that of {REW_DEPTH_CONV}:
{
   #let th = ADD_ASSUM "n = 0" ADD_0;;
   th = n = 0 |- !m. m + 0 = m

   #REW_DEPTH_CONV (REWR_CONV th) "\n. n + 0";;
   n = 0 |- (\n. n + 0) = (\n. n)

   #TOP_DEPTH_CONV (REWR_CONV th) "\n. n + 0";;
   |- (\n. n + 0) = (\n. n + 0)
}
\COMMENTS
The implementation of this function uses failure to avoid rebuilding
unchanged subterms. That is to say, during execution the failure string
{`QCONV`} may be generated and later trapped. The behaviour of the function
is dependent on this use of failure. So, if the conversion given as argument
happens to generate a failure with string {`QCONV`}, the operation of
{REW_DEPTH_CONV} will be unpredictable.

\SEEALSO
ONCE_REW_DEPTH_CONV, TOP_DEPTH_CONV.

\ENDDOC
