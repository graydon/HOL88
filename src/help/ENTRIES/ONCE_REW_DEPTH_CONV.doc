\DOC ONCE_REW_DEPTH_CONV

\TYPE {ONCE_REW_DEPTH_CONV : (conv -> conv)}

\SYNOPSIS
Applies a conversion once to the first suitable sub-term(s) encountered in
top-down order. For use in rewriting.

\KEYWORDS
conversional.

\DESCRIBE
{ONCE_REW_DEPTH_CONV c tm} applies the conversion {c} once to the first
subterm or subterms encountered in a top-down `parallel' search of the term
{tm} for which {c} succeeds.  If the conversion {c} fails on all subterms of
{tm}, the theorem returned is {|- tm = tm}.

{ONCE_REW_DEPTH_CONV} is a special version of {ONCE_DEPTH_CONV} for use by the
rewriting conversions, rules and tactics. It differs from {ONCE_DEPTH_CONV} as
follows: If converting an abstraction fails due to the presence of the bound
variable in the hypotheses of the theorem generated by converting the body,
{ONCE_REW_DEPTH_CONV} retries the conversion having renamed the bound variable
of the abstraction. If successful the renaming is reversed.

\FAILURE
Never fails.

\EXAMPLE
The following example illustrates the difference between the functions
{ONCE_REW_DEPTH_CONV} and {ONCE_DEPTH_CONV}. It is not intended to illustrate
the full range of behaviour of the former. Both {ONCE_REW_DEPTH_CONV} and
{ONCE_DEPTH_CONV} successfully apply the theorem {ADD_0} inside an abstraction:
{
   #ONCE_REW_DEPTH_CONV (REWR_CONV ADD_0) "\n. n + 0";;
   |- (\n. n + 0) = (\n. n)

   #ONCE_DEPTH_CONV (REWR_CONV ADD_0) "\n. n + 0";;
   |- (\n. n + 0) = (\n. n)
}
\noindent However, if a hypothesis containing a free occurrence of the bound
variable is added to the rewrite rule, it interferes with the operation of
{ONCE_DEPTH_CONV} but not that of {ONCE_REW_DEPTH_CONV}:
{
   #let th = ADD_ASSUM "n = 0" ADD_0;;
   th = n = 0 |- !m. m + 0 = m

   #ONCE_REW_DEPTH_CONV (REWR_CONV th) "\n. n + 0";;
   n = 0 |- (\n. n + 0) = (\n. n)

   #ONCE_DEPTH_CONV (REWR_CONV th) "\n. n + 0";;
   |- (\n. n + 0) = (\n. n + 0)
}
\COMMENTS
The implementation of this function uses failure to avoid rebuilding
unchanged subterms. That is to say, during execution the failure string
{`QCONV`} may be generated and later trapped. The behaviour of the function
is dependent on this use of failure. So, if the conversion given as argument
happens to generate a failure with string {`QCONV`}, the operation of
{ONCE_REW_DEPTH_CONV} will be unpredictable.

\SEEALSO
REW_DEPTH_CONV, ONCE_DEPTH_CONV.

\ENDDOC
